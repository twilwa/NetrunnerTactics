The response has been limited to 50k tokens of the smallest files in the repo. You can remove this limitation by
removing the max tokens filter.


```
└── src
    └── clj
        └── game
            ├── cards
                ├── agendas.clj
                ├── assets.clj
                ├── basic.clj
                ├── events.clj
                ├── hardware.clj
                ├── ice.clj
                ├── identities.clj
                ├── operations.clj
                ├── programs.clj
                ├── resources.clj
                └── upgrades.clj
            ├── core.clj
            ├── core
                ├── access.clj
                ├── actions.clj
                ├── agendas.clj
                ├── bad_publicity.clj
                ├── board.clj
                ├── card_defs.clj
                ├── change_vals.clj
                ├── charge.clj
                ├── checkpoint.clj
                ├── choose_one.clj
                ├── commands.clj
                ├── cost_fns.clj
                ├── costs.clj
                ├── damage.clj
                ├── def_helpers.clj
                ├── diffs.clj
                ├── drawing.clj
                ├── effects.clj
                ├── eid.clj
                ├── engine.clj
                ├── events.clj
                ├── expend.clj
                ├── expose.clj
                ├── finding.clj
                ├── flags.clj
                ├── gaining.clj
                ├── hand_size.clj
                ├── hosting.clj
                ├── ice.clj
                ├── identities.clj
                ├── initializing.clj
                ├── installing.clj
                ├── link.clj
                ├── mark.clj
                ├── memory.clj
                ├── moving.clj
                ├── optional.clj
                ├── payment.clj
                ├── pick_counters.clj
                ├── play_instants.clj
                ├── player.clj
                ├── prevention.clj
                ├── process_actions.clj
                ├── prompt_state.clj
                ├── prompts.clj
                ├── props.clj
                ├── psi.clj
                ├── purging.clj
                ├── revealing.clj
                ├── rezzing.clj
                ├── runs.clj
                ├── sabotage.clj
                ├── say.clj
                ├── servers.clj
                ├── set_aside.clj
                ├── set_up.clj
                ├── shuffling.clj
                ├── state.clj
                ├── subtypes.clj
                ├── tags.clj
                ├── threat.clj
                ├── to_string.clj
                ├── toasts.clj
                ├── trace.clj
                ├── turns.clj
                ├── update.clj
                ├── virus.clj
                └── winning.clj
            ├── macros.clj
            ├── main.clj
            ├── quotes.clj
            └── utils.clj

/src/clj/game/core/agendas.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.agendas
 2 |   (:require
 3 |     [game.core.board :refer [get-all-cards]]
 4 |     [game.core.card :refer [agenda? map->Card]]
 5 |     [game.core.card-defs :refer [card-def]]
 6 |     [game.core.effects :refer [sum-effects]]
 7 |     [game.core.eid :refer [make-eid]]
 8 |     [game.core.update :refer [update!]]))
 9 |
10 | (defn- advancement-requirement
11 |   [state {:keys [advancementcost] :as card}]
12 |   (when (agenda? card)
13 |     (->> [advancementcost\
14 |           (when-let [advance-fn (:advancement-requirement (card-def card))]\
15 |             (advance-fn state :corp (make-eid state) card nil))\
16 |           (sum-effects state :corp :advancement-requirement card)]
17 |          (reduce (fnil + 0 0))
18 |          (max 0))))
19 |
20 | (defn update-advancement-requirement
21 |   "Recalculates the advancement requirement for the given agenda."
22 |   ([state agenda] (update-advancement-requirement state nil agenda))
23 |   ([state _ agenda]
24 |    (let [prev-req (:current-advancement-requirement agenda)\
25 |          new-req (advancement-requirement state agenda)\
26 |          changed? (not= prev-req new-req)]
27 |      (when changed?
28 |        (update! state :corp (assoc agenda :current-advancement-requirement new-req)))
29 |      changed?)))
30 |
31 | (defn update-all-advancement-requirements
32 |   ([state] (update-all-advancement-requirements state nil))
33 |   ([state _]
34 |    (reduce
35 |      (fn [changed? agenda]
36 |        (or (update-advancement-requirement state agenda)
37 |            changed?))
38 |      false
39 |      (filter agenda? (get-all-cards state)))))
40 |
41 | (defn agenda-points
42 |   "Apply agenda-point modifications to calculate the number of points this card is worth
43 |   to the given player."
44 |   [state side card]
45 |   (when (some? card)
46 |     (let [base-points (:agendapoints card 0)\
47 |           points-fn (if (= side :corp)\
48 |                       (:agendapoints-corp (card-def card))\
49 |                       (:agendapoints-runner (card-def card)))]
50 |       (if (fn? points-fn)
51 |         (+ (points-fn state side nil card nil)
52 |            (sum-effects state side :agenda-value card))
53 |         (+ base-points
54 |            (sum-effects state side :agenda-value card))))))
55 |
56 | (defn- update-agenda-points-card
57 |   [state side card]
58 |   (let [prev-points (:current-points card)\
59 |         new-points (agenda-points state side card)\
60 |         changed? (not= prev-points new-points)]
61 |     (when changed?
62 |       (update! state side (assoc card :current-points new-points)))
63 |     changed?))
64 |
65 | (defn- sum-side-agenda-points
66 |   [state side]
67 |   (let [current-points (or (get-in @state [side :agenda-point]) 0)\
68 |         user-adjusted-points (sum-effects state side :user-agenda-points side)\
69 |         scored-points (->> (get-in @state [side :scored])\
70 |                            (keep :current-points)\
71 |                            (reduce + 0))\
72 |         total-points (+ user-adjusted-points scored-points)\
73 |         changed? (not= current-points total-points)]
74 |     (when changed?
75 |       (swap! state assoc-in [side :agenda-point] total-points))
76 |     changed?))
77 |
78 | (defn- update-side-agenda-points
79 |   [state side]
80 |   (let [card-points-changed?\
81 |         (reduce (fn [changed? agenda]\
82 |                   (or (update-agenda-points-card state side agenda)\
83 |                       changed?))\
84 |                 false\
85 |                 (get-in @state [side :scored]))]
86 |     (or (sum-side-agenda-points state side)
87 |         card-points-changed?)))
88 |
89 | (defn update-all-agenda-points
90 |   ([state] (update-all-agenda-points state nil))
91 |   ([state _]
92 |    (let [corp-changed? (update-side-agenda-points state :corp)\
93 |          runner-changed? (update-side-agenda-points state :runner)]
94 |      (or corp-changed? runner-changed?))))
95 |

--------------------------------------------------------------------------------
/src/clj/game/core/bad_publicity.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.bad-publicity
 2 |   (:require
 3 |     [game.core.eid :refer [effect-completed make-eid make-result]]
 4 |     [game.core.engine :refer [queue-event checkpoint trigger-event-sync]]
 5 |     [game.core.gaining :refer [gain lose]]
 6 |     [game.core.prompts :refer [clear-wait-prompt show-prompt show-wait-prompt]]
 7 |     [game.core.prevention :refer [resolve-bad-pub-prevention]]
 8 |     [game.core.say :refer [system-msg]]
 9 |     [game.core.toasts :refer [toast]]
10 |     [game.macros :refer [wait-for]]))
11 |
12 | (defn- resolve-bad-publicity
13 |   [state side eid n {:keys [suppress-checkpoint] :as args}]
14 |   (if (pos? n)
15 |     (do (gain state :corp :bad-publicity n)
16 |         (toast state :corp (str "Took " n " bad publicity!") "info")
17 |         (queue-event state :corp-gain-bad-publicity {:amount n})
18 |         (if suppress-checkpoint
19 |           (effect-completed state side eid)
20 |           (checkpoint state eid)))
21 |     (effect-completed state side eid)))
22 |
23 | (defn gain-bad-publicity
24 |   "Attempts to give the corp n bad publicity, allowing for boosting/prevention effects."
25 |   ([state side n] (gain-bad-publicity state side (make-eid state) n nil))
26 |   ([state side eid n] (gain-bad-publicity state side eid n nil))
27 |   ([state side eid n {:keys [unpreventable card] :as args}]
28 |    (wait-for (resolve-bad-pub-prevention state side n args)
29 |              (resolve-bad-publicity state side eid (:remaining async-result) args))))
30 |
31 | (defn lose-bad-publicity
32 |   ([state side n] (lose-bad-publicity state side (make-eid state) n))
33 |   ([state side eid n]
34 |    (if (= n :all)
35 |      (lose-bad-publicity state side eid (get-in @state [:corp :bad-publicity :base]))
36 |      (do (lose state :corp :bad-publicity n)
37 |          (trigger-event-sync state side eid :corp-lose-bad-publicity {:amount n
38 |                                                                       :side side})))))
39 |

--------------------------------------------------------------------------------
/src/clj/game/core/board.clj:
--------------------------------------------------------------------------------
  1 | (ns game.core.board
  2 |   (:require
  3 |    [clojure.string :as string]
  4 |    [game.core.card :refer [agenda? asset? corp? event? facedown? installed?\
  5 |                            is-type? operation? rezzed? runner?]]
  6 |    [game.core.card-defs :refer [card-def]]
  7 |    [game.core.eid :refer [make-eid]]
  8 |    [game.core.servers :refer [is-remote? zones->sorted-names]]
  9 |    [game.utils :refer [dissoc-in to-keyword]]))
 10 |
 11 | (defn corp-servers-cards [state]
 12 |   (for [server (vals (:servers (:corp @state)))\
 13 |         installed-card (into (:content server) (:ices server))]
 14 |     installed-card))
 15 |
 16 | (defn runner-rig-cards [state]
 17 |   (for [row (vals (:rig (:runner @state)))\
 18 |         installed-card row]
 19 |     installed-card))
 20 |
 21 | (defn get-all-cards
 22 |   "Every single card in the game. All cards in the hand, deck, discard, play-area, set-aside,
 23 |   score zone, currents, and removed from the game. And all cards that are installed and hosted"
 24 |   [state]
 25 |   (let [installed-corp (corp-servers-cards state)\
 26 |         installed-runner (runner-rig-cards state)\
 27 |         corp (:corp @state)\
 28 |         runner (:runner @state)\
 29 |         cards-in-zones (for [side [corp runner]\
 30 |                              zone [:deck :hand :discard :current :scored :play-area :rfg :set-aside]\
 31 |                              card (zone side)]\
 32 |                          card)\
 33 |         identities (list (:identity corp) (:identity runner))]
 34 |     (loop [checked (transient [])\
 35 |            unchecked (concat installed-corp installed-runner cards-in-zones identities)]
 36 |       (if (empty? unchecked)
 37 |         (persistent! checked)
 38 |         (let [[card & remaining] unchecked]
 39 |           (if card
 40 |             (recur (conj! checked card) (into remaining (:hosted card)))
 41 |             (recur checked remaining)))))))
 42 |
 43 | (defn all-installed-runner
 44 |   [state]
 45 |   (let [installed-cards (runner-rig-cards state)\
 46 |         hosted-on-corp-cards (mapcat :hosted (corp-servers-cards state))]
 47 |     (loop [installed (transient [])\
 48 |            unchecked (into installed-cards hosted-on-corp-cards)]
 49 |       (if (empty? unchecked)
 50 |         (persistent! installed)
 51 |         (let [[card & remaining] unchecked]
 52 |           (recur
 53 |             (if (and (runner? card)
 54 |                      (installed? card))
 55 |               (conj! installed card)
 56 |               installed)
 57 |             (into remaining (:hosted card))))))))
 58 |
 59 | (defn all-installed-corp
 60 |   [state]
 61 |   (let [installed-cards (corp-servers-cards state)\
 62 |         hosted-on-runner-cards (mapcat :hosted (runner-rig-cards state))]
 63 |     (loop [installed (transient [])\
 64 |            unchecked (into installed-cards hosted-on-runner-cards)]
 65 |       (if (empty? unchecked)
 66 |         (persistent! installed)
 67 |         (let [[card & remaining] unchecked]
 68 |           (recur
 69 |             (if (and (corp? card)
 70 |                      (installed? card))
 71 |               (conj! installed card)
 72 |               installed)
 73 |             (into remaining (:hosted card))))))))
 74 |
 75 | (defn all-installed
 76 |   "Returns a vector of all installed cards for the given side, including those hosted on other cards,
 77 |   but not including 'inactive hosting' like Personal Workshop."
 78 |   [state side]
 79 |   (if (= side :runner)
 80 |     (all-installed-runner state)
 81 |     (all-installed-corp state)))
 82 |
 83 | (defn all-installed-and-scored
 84 |   "Returns a vector of all installed cards for the given side, including those hosted on other cards,
 85 |    but not including 'inactive hosting' like Personal Workshop, and the cards in the given side's scored area."
 86 |   [state side]
 87 |   (concat (all-installed state side)
 88 |           (-> @state side :scored)))
 89 |
 90 | (defn get-all-installed
 91 |   "Returns a list of all installed cards"
 92 |   [state]
 93 |   (let [installed-runner-cards (runner-rig-cards state)\
 94 |         installed-corp-cards (corp-servers-cards state)]
 95 |     (loop [installed (transient [])\
 96 |            unchecked (concat installed-runner-cards\
 97 |                              installed-corp-cards)]
 98 |       (if (empty? unchecked)
 99 |         (persistent! installed)
100 |         (let [[card & remaining] unchecked]
101 |           (recur
102 |             (if (installed? card)
103 |               (conj! installed card)
104 |               installed)
105 |             (into (vec remaining) (:hosted card))))))))
106 |
107 | (defn all-installed-runner-type
108 |   "Returns a list of all installed, non-facedown runner cards of the requested type."
109 |   [state card-type]
110 |   (filter #(and (is-type? % card-type) (not (facedown? %))) (all-installed state :runner)))
111 |
112 | (defn all-active-installed
113 |   "Returns a vector of active AND installed cards for the given side. This is all face-up installed cards."
114 |   [state side]
115 |   (let [installed (all-installed state side)]
116 |     (if (= side :runner)
117 |       (remove facedown? installed)
118 |       (filter rezzed? installed))))
119 |
120 | (defn all-active
121 |   "Returns a sequence of all active cards for the given side. Active cards are either installed, the identity,
122 |   currents, or the corp's scored area."
123 |   [state side]
124 |   (->> (concat [(-> @state side :identity)]
125 |                (all-active-installed state side)
126 |                (-> @state side :current)
127 |                (filter (if (= :corp side) operation? event?)
128 |                        (-> @state side :play-area))
129 |                (when (= side :corp)
130 |                  (-> @state :corp :scored)))
131 |        (filter identity)
132 |        (remove :disabled)))
133 |
134 | (defn installed-byname
135 |   "Returns a truthy card map if a card matching title is installed"
136 |   [state side title]
137 |   (some #(when (= (:title %) title) %) (all-active-installed state side)))
138 |
139 | (defn in-play?
140 |   "Returns a truthy card map if the given card is in play (installed)."
141 |   [state card]
142 |   (installed-byname state (to-keyword (:side card)) (:title card)))
143 |
144 | ;; zone stuff
145 | (defn get-zones [state]
146 |   (keys (get-in @state [:corp :servers])))
147 |
148 | (defn get-remote-zones [state]
149 |   (filter is-remote? (get-zones state)))
150 |
151 | (defn get-remotes [state]
152 |   (select-keys (get-in @state [:corp :servers]) (get-remote-zones state)))
153 |
154 | (defn get-remote-names [state]
155 |   (zones->sorted-names (get-remote-zones state)))
156 |
157 | (defn server-list
158 |   "Get a list of all servers (including centrals)"
159 |   [state]
160 |   (zones->sorted-names (get-zones state)))
161 |
162 | (defn installable-servers
163 |   "Get list of servers the specified card can be installed in"
164 |   [state card]
165 |   (let [max-servers (when-not (get (:disabled-card-reg @state) (get-in @state [:corp :identity :cid]))\
166 |                       (get-in (card-def (get-in @state [:corp :identity])) [:flags :server-limit]))\
167 |         at-remote-limit? (and max-servers (>= (count (get-remotes state)) max-servers))\
168 |         hosts (filter #(when-let [can-host (:can-host (card-def %))]\
169 |                          (and (rezzed? %)\
170 |                               (can-host state :corp (make-eid state) % [card])))\
171 |                       (all-installed state :corp))\
172 |         base-list (concat hosts (server-list state) (when-not at-remote-limit? ["New remote"]))]
173 |     (if-let [install-req (-> card card-def :install-req)]
174 |       ;; Install req function overrides normal list of install locations
175 |       (install-req state :corp card (make-eid state) base-list)
176 |       ;; Standard list
177 |       (if (or (agenda? card)
178 |               (asset? card))
179 |         (remove #{"HQ" "R&D" "Archives"} base-list)
180 |         base-list))))
181 |
182 | (defn server->zone [state server]
183 |   (if (sequential? server)
184 |     (vec (cons :servers server))
185 |     (if (:cid server)
186 |       [:onhost]
187 |       (case server
188 |         "HQ" [:servers :hq]
189 |         "R&D" [:servers :rd]
190 |         "Archives" [:servers :archives]
191 |         "New remote" [:servers (keyword (str "remote" (:rid @state)))]
192 |         [:servers (->> (string/split server #" ") last (str "remote") keyword)]))))
193 |
194 | (defn card->server
195 |   "Returns the server map that this card is installed in or protecting."
196 |   [state card]
197 |   (let [z (:zone card)]
198 |     (get-in @state [:corp :servers (second z)])))
199 |
200 | (defn clear-empty-remotes
201 |   [state]
202 |   (doseq [remote (get-remotes state)]
203 |     (let [zone [:corp :servers (first remote)]]
204 |       (when (and (empty? (get-in @state (conj zone :content)))
205 |                  (empty? (get-in @state (conj zone :ices))))
206 |         (swap! state dissoc-in zone)))))
207 |

--------------------------------------------------------------------------------
/src/clj/game/core/card_defs.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.card-defs)
 2 |
 3 | (defmulti defcard-impl (fn [title] title))
 4 | (defmethod defcard-impl :default [_] nil)
 5 |
 6 | (defn card-def
 7 |   "Retrieves a card's abilities definition map."
 8 |   [{:keys [printed-title title] :as card}]
 9 |   (cond
10 |     title (or (defcard-impl title) {})
11 |     printed-title (or (defcard-impl printed-title) {})
12 |     :else (throw (ex-info "Tried to select card def for non-existent card"
13 |                           {:msg "Tried to select card-def for non existent card"
14 |                            :card card}))))
15 |

--------------------------------------------------------------------------------
/src/clj/game/core/change_vals.clj:
--------------------------------------------------------------------------------
  1 | (ns game.core.change-vals
  2 |   (:require
  3 |     [game.core.agendas :refer [update-all-agenda-points]]
  4 |     [game.core.effects :refer [register-lingering-effect]]
  5 |     [game.core.engine :refer [trigger-event]]
  6 |     [game.core.gaining :refer [base-mod-size deduct gain]]
  7 |     [game.core.hand-size :refer [hand-size update-hand-size]]
  8 |     [game.core.link :refer [get-link update-link]]
  9 |     [game.core.memory :refer [available-mu update-mu]]
 10 |     [game.core.say :refer [system-msg]]
 11 |     [game.core.tags :refer [update-tag-status]]
 12 |     [game.macros :refer [req]]))
 13 |
 14 | (defn- change-msg
 15 |   "Send a system message indicating the property change"
 16 |   [state side kw new-val delta]
 17 |   (let [key (cond\
 18 |               (= kw :brain-damage) "core damage"\
 19 |               :else (name kw))]
 20 |     (system-msg state side
 21 |                 (str "sets " (.replace key "-" " ") " to " new-val
 22 |                      " (" (if (pos? delta) (str "+" delta) delta) ")"))))
 23 |
 24 | (defn- change-map
 25 |   "Change a player's property using the :mod system"
 26 |   [state side key delta]
 27 |   (gain state side key {:mod delta})
 28 |   (change-msg state side key (base-mod-size state side key) delta))
 29 |
 30 | (defn- change-mu
 31 |   "Send a system message indicating how mu was changed"
 32 |   [state side delta]
 33 |   (register-lingering-effect
 34 |     state side nil
 35 |     {:type :user-available-mu
 36 |      :value [:regular delta]})
 37 |   (update-mu state)
 38 |   (system-msg state side
 39 |               (str "sets unused [mu] to " (available-mu state)
 40 |                    " (" (if (pos? delta) (str "+" delta) delta) ")")))
 41 |
 42 | (defn- change-tags
 43 |   "Change a player's tag count"
 44 |   [state delta]
 45 |   (gain state :runner :tag delta)
 46 |   (update-tag-status state)
 47 |   (system-msg state :runner
 48 |               (str "sets Tags to " (get-in @state [:runner :tag :total])
 49 |                    " (" (if (pos? delta) (str "+" delta) delta) ")")))
 50 |
 51 | (defn- change-bad-pub
 52 |   "Change a player's base bad pub count"
 53 |   [state delta]
 54 |   (if (neg? delta)
 55 |     (deduct state :corp [:bad-publicity (Math/abs delta)])
 56 |     (gain state :corp :bad-publicity delta))
 57 |   (system-msg state :corp
 58 |               (str "sets Bad Publicity to " (get-in @state [:corp :bad-publicity :base])
 59 |                    " (" (if (pos? delta) (str "+" delta) delta) ")")))
 60 |
 61 | (defn- change-agenda-points
 62 |   "Change a player's total agenda points, using floating effects."
 63 |   [state side delta]
 64 |   (register-lingering-effect
 65 |     state side nil
 66 |     ;; This is needed as `req` creates/shadows the existing `side` already in scope.
 67 |     (let [user-side side]
 68 |       {:type :user-agenda-points
 69 |        ;; `target` is either `:corp` or `:runner`
 70 |        :req (req (= user-side target))
 71 |        :value delta}))
 72 |   (update-all-agenda-points state side)
 73 |   (system-msg state side
 74 |               (str "sets [their] agenda points to " (get-in @state [side :agenda-point])
 75 |                    " (" (if (pos? delta) (str "+" delta) delta) ")")))
 76 |
 77 | (defn- change-link
 78 |   "Change the runner's link, using floating effects."
 79 |   [state side delta]
 80 |   (register-lingering-effect
 81 |     state side nil
 82 |     {:type :user-link
 83 |      :value delta})
 84 |   (update-link state)
 85 |   (system-msg state side
 86 |               (str "sets [their] [link] to " (get-link state)
 87 |                    " (" (if (pos? delta) (str "+" delta) delta) ")")))
 88 |
 89 | (defn- change-hand-size
 90 |   "Change the player's hand-size, using floating effects."
 91 |   [state side delta]
 92 |   (register-lingering-effect
 93 |     state side nil
 94 |     (let [user-side side]
 95 |       {:type :user-hand-size
 96 |        :req (req (= side user-side))
 97 |        :value delta}))
 98 |   (update-hand-size state side)
 99 |   (system-msg state side
100 |               (str "sets [their] hand size to " (hand-size state side)
101 |                    " (" (if (pos? delta) (str "+" delta) delta) ")")))
102 |
103 | (defn- change-generic
104 |   "Change a player's base generic property."
105 |   [state side key delta]
106 |   (if (neg? delta)
107 |     (deduct state side [key (- delta)])
108 |     (swap! state update-in [side key] (partial + delta)))
109 |   (change-msg state side key (get-in @state [side key]) delta))
110 |
111 | (defn change
112 |   "Increase/decrease a player's property (clicks, credits, MU, etc.) by delta."
113 |   [state side {:keys [key delta]}]
114 |   (case key
115 |     :memory (change-mu state side delta)
116 |     :hand-size (change-hand-size state side delta)
117 |     :tag (change-tags state delta)
118 |     :bad-publicity (change-bad-pub state delta)
119 |     :agenda-point (change-agenda-points state side delta)
120 |     :link (change-link state side delta)
121 |     ; else
122 |     (change-generic state side key delta)))
123 |

--------------------------------------------------------------------------------
/src/clj/game/core/charge.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.charge
 2 |   (:require
 3 |    [game.core.board :refer [all-installed]]
 4 |    [game.core.card :refer :all]
 5 |    [game.core.eid :refer [effect-completed]]
 6 |    [game.core.say :refer [system-msg]]
 7 |    [game.macros :refer [req msg effect]]
 8 |    [game.core.props :refer [add-counter]]))
 9 |
10 | (defn can-charge
11 |   "A card can be charged if it has at least one power counter"
12 |   ([state side]
13 |    (let [cards (all-installed state side)]
14 |      (some #(can-charge state side %) cards)))
15 |   ([state side card]
16 |    (pos? (get-counters (get-card state card) :power))))
17 |
18 | (defn charge-card
19 |   "Charge: place a power counter on a card that has at least one power counter"
20 |   ([state side eid target]
21 |    (charge-card state side eid target 1))
22 |   ([state side eid target count]
23 |    (if (can-charge state side target)
24 |      (add-counter state side eid target :power count {:placed true})
25 |      (effect-completed state side eid))))
26 |
27 | (defn charge-ability
28 |   "Creates a charge prompt (if there is a valid target) to charge a card once"
29 |   ([state side]
30 |    (charge-ability state side 1))
31 |   ([state side n]
32 |    (when (can-charge state side)
33 |      {:waiting-prompt true
34 |       :prompt "Choose an installed card"
35 |       :choices {:card #(can-charge state side %)}
36 |       :async true
37 |       :msg (msg "charge " (:title target) (when (> n 1) (str n " times")))
38 |       :cancel-effect (effect (system-msg (str "declines to use " (:title card) " to charge a card"))
39 |                              (effect-completed eid))
40 |       :effect (req (charge-card state side eid target n))})))
41 |

--------------------------------------------------------------------------------
/src/clj/game/core/checkpoint.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.checkpoint
 2 |   (:require
 3 |    [game.core.agendas :refer [update-all-advancement-requirements update-all-agenda-points]]
 4 |    [game.core.actions :refer [generate-runnable-zones]]
 5 |    [game.core.board :refer [get-remotes clear-empty-remotes]]
 6 |    [game.core.effects :refer [update-disabled-cards]]
 7 |    [game.core.ice :refer [update-all-ice update-all-icebreakers]]
 8 |    [game.core.hand-size :refer [update-hand-size]]
 9 |    [game.core.initializing :refer [update-all-card-labels]]
10 |    [game.core.link :refer [update-link]]
11 |    [game.core.memory :refer [update-mu]]
12 |    [game.core.subtypes :refer [update-all-subtypes]]
13 |    [game.core.tags :refer [update-tag-status]]))
14 |
15 | (defn fake-checkpoint
16 |   [state]
17 |   (loop [i 0]
18 |     (let [changed [(update-all-ice state :corp)\
19 |                    (update-all-icebreakers state :runner)\
20 |                    (update-all-card-labels state)\
21 |                    (update-all-advancement-requirements state)\
22 |                    (update-all-agenda-points state)\
23 |                    (update-link state)\
24 |                    (update-mu state)\
25 |                    (update-hand-size state :corp)\
26 |                    (update-hand-size state :runner)\
27 |                    (update-all-subtypes state)\
28 |                    (update-tag-status state)]]
29 |       (when (and (some true? changed)
30 |                  (< i 10))
31 |         (recur (inc i)))))
32 |   (clear-empty-remotes state)
33 |   (generate-runnable-zones state nil nil))
34 |

--------------------------------------------------------------------------------
/src/clj/game/core/choose_one.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.choose-one
 2 |   (:require
 3 |    [game.macros :refer [continue-ability req wait-for]]
 4 |    [game.core.engine :refer [resolve-ability]]
 5 |    [game.core.payment :refer [build-cost-string can-pay?]]
 6 |    [game.core.eid :refer [effect-completed make-eid]]
 7 |    [clojure.string :as str]))
 8 |
 9 | (defn choose-one-helper
10 |   ;; keys unique to this function:
11 |   ;;   no-prune: can I select the same option more than once?
12 |   ;;   no-wait-msg: do we hide the wait message from the runner?
13 |   ;;   count: number of choices we're allowed to pick
14 |   ([xs] (choose-one-helper nil xs))
15 |   ([{:keys [prompt count optional no-prune no-wait-msg interactive require-meaningful-choice] :as args} xs]
16 |    ;;the 'prompt' key cant compute 5-fns, so this needs to be disambiguated
17 |    (if (fn? (:count args))
18 |      {:async true
19 |       :effect (req (let [new-count ((:count args) state side eid card targets)]
20 |                      (continue-ability
21 |                        state side
22 |                        (choose-one-helper (assoc args :count new-count) xs)
23 |                        card nil)))}
24 |      ;; xs of the form {:option ... :req (req ...) :cost ... :ability ..}
25 |      (let [next-optional (= optional :after-first)\
26 |            apply-optional (and optional (not next-optional))\
27 |            xs (if-not apply-optional xs (conj xs {:option "Done"}))\
28 |            base-map (select-keys args [:action :player :once :unregister-once-resolved :event\
29 |                                        :label :change-in-game-state :location :additional-cost])\
30 |            ;; is a choice payable\
31 |            payable? (fn [x state side eid card targets]\
32 |                       (when (or (not (:cost x))\
33 |                                 (can-pay? state (or (:player args) side) eid card nil (:cost x)))\
34 |                         x))\
35 |            ;; cost->str for a choice\
36 |            costed-str (fn [x]\
37 |                         (let [choice-str (if-not (:cost x)\
38 |                                            (:option x)\
39 |                                            (let [cs (build-cost-string (:cost x))]\
40 |                                              (if-not (:option x) cs (str cs ": " (:option x)))))]\
41 |                           (if (:card x)\
42 |                             (assoc (:card x) :title choice-str)\
43 |                             choice-str)))\
44 |            ;; converts options to choices\
45 |            choices-fn (fn [x state side eid card targets]\
46 |                         (when (payable? x state side eid card targets)\
47 |                           (if-not (:req x)\
48 |                             (costed-str x)\
49 |                             (when ((:req x) state side eid card targets)\
50 |                               (costed-str x)))))\
51 |            ;; this lets us selectively skip the prompt if 'done' is the only choice\
52 |            meaningful-req? (when require-meaningful-choice\
53 |                              (req (let [cs (keep #(choices-fn % state side eid card targets) xs)]\
54 |                                     (and (not= cs ["Done"])\
55 |                                          (or (nil? (:req args))\
56 |                                              ((:req args) state side eid card targets))))))]
57 |        ;; function for resolving choices: pick the matching choice, pay, resolve it, and continue
58 |        ;; when applicable
59 |        (letfn [(resolve-choices [xs full state side eid card target]\
60 |                  (if-not (seq xs)\
61 |                    (effect-completed state side eid )\
62 |                    (if (= target (costed-str (first xs)))\
63 |                      ;; allow for resolving multiple options, like deuces wild\
64 |                      (wait-for\
65 |                        (resolve-ability\
66 |                          state side (make-eid state eid)\
67 |                          (assoc (:ability (first xs)) :cost (:cost (first xs)))\
68 |                          card nil) ;; below is maybe superflous\
69 |                        (if (and count (> count 1) (not= target "Done"))\
70 |                          ;; the 'Done' is already there, so can dissoc optional\
71 |                          (let [args (assoc args :count (dec count) :optional next-optional)\
72 |                                xs (if no-prune full\
73 |                                       (vec (remove #(= target (costed-str %)) full)))]\
74 |                            (continue-ability state side (choose-one-helper args xs) card nil))\
75 |                          (effect-completed state side eid)))\
76 |                      (resolve-choices (rest xs) full state side eid card target))))]
77 |          (merge
78 |            base-map
79 |            {:choices (req (into [] (map #(choices-fn % state side eid card targets) xs)))
80 |             :waiting-prompt (or (:waiting-prompt args) (not no-wait-msg))
81 |             :prompt (str (or (:prompt args) "Choose one")
82 |                          ;; if we are resolving multiple
83 |                          (when (and count (pos? count)) (str " (" count " remaining)")))
84 |             :req (or meaningful-req? (:req args))
85 |             ;; resolve-choices demands async
86 |             :async true
87 |             ;; interactive expects a 5-fn or nil
88 |             ;; but I want to just be able to say True or False
89 |             :interactive (when interactive (if-not (fn? interactive) (req interactive) interactive))
90 |             :effect (req (resolve-choices xs xs state side eid card target))}))))))
91 |
92 | (defn cost-option
93 |   [cost side]
94 |   {:cost cost
95 |    :ability {:display-side side
96 |              :msg :cost}})
97 |

--------------------------------------------------------------------------------
/src/clj/game/core/cost_fns.clj:
--------------------------------------------------------------------------------
  1 | (ns game.core.cost-fns
  2 |   (:require
  3 |     [game.core.card :refer [runner?]]
  4 |     [game.core.card-defs :refer [card-def]]
  5 |     [game.core.effects :refer [any-effects get-effects sum-effects get-effect-maps get-effect-value is-disabled-reg?]]
  6 |     [game.core.eid :refer [make-eid]]
  7 |     [game.core.payment :refer [merge-costs]]))
  8 |
  9 | ;; State-aware cost-generating functions
 10 | (defn play-cost
 11 |   "Combines all relevant effects and costs to play a given card"
 12 |   ([state side card] (play-cost state side card nil))
 13 |   ([state side {:keys [cost] :as card} {:keys [cost-bonus]}]
 14 |    (when-not (nil? cost)
 15 |      (->> [cost\
 16 |            (or cost-bonus 0)\
 17 |            (when-let [playfun (get-in (card-def card) [:on-play :play-cost-bonus])]\
 18 |              (playfun state side (make-eid state) card nil))\
 19 |            (sum-effects state side :play-cost card)]
 20 |           (reduce (fnil + 0 0))
 21 |           (max 0)))))
 22 |
 23 | (defn play-additional-cost-bonus
 24 |   [state side card]
 25 |   (merge-costs
 26 |     (concat (get-in (card-def card) [:on-play :additional-cost])
 27 |             (get-effects state side :play-additional-cost card))))
 28 |
 29 | (defn rez-cost
 30 |   "Combines all rez effects and costs into a single number, not a cost vector"
 31 |   ([state side card] (rez-cost state side card nil))
 32 |   ([state side {:keys [cost] :as card} {:keys [cost-bonus]}]
 33 |    (when-not (nil? cost)
 34 |      (->> [cost\
 35 |            (or cost-bonus 0)\
 36 |            (when-let [rezfun (and (not (is-disabled-reg? state card))\
 37 |                                   (:rez-cost-bonus (card-def card)))]\
 38 |              (rezfun state side (make-eid state) card nil))\
 39 |            (sum-effects state side :rez-cost card)]
 40 |           (reduce (fnil + 0 0))
 41 |           (max 0)))))
 42 |
 43 | (defn rez-additional-cost-bonus
 44 |   ([state side card] (rez-additional-cost-bonus state side card nil))
 45 |   ([state side card pred]
 46 |    (let [costs (merge-costs\
 47 |                  [(when-not (is-disabled-reg? state card) (:additional-cost (card-def card)))\
 48 |                   (get-effects state side :rez-additional-cost card)])]
 49 |      (filterv (or pred identity) costs))))
 50 |
 51 | (defn score-additional-cost-bonus
 52 |   [state side card]
 53 |   (merge-costs
 54 |     [(:additional-cost (card-def card))\
 55 |      (get-effects state side :score-additional-cost card)]))
 56 |
 57 | (defn trash-cost
 58 |   "Returns the number of credits required to trash the given card."
 59 |   ([state side card] (trash-cost state side card nil))
 60 |   ([state side {:keys [trash] :as card} {:keys [cost-bonus]}]
 61 |    (when-not (nil? trash)
 62 |      (->> [trash\
 63 |            (or cost-bonus 0)\
 64 |            (when-let [trashfun (:trash-cost-bonus (card-def card))]\
 65 |              (trashfun state side (make-eid state) card nil))\
 66 |            (sum-effects state side :trash-cost card)]
 67 |           (reduce (fnil + 0 0))
 68 |           (max 0)))))
 69 |
 70 | (defn install-cost
 71 |   "Returns the number of credits required to install the given card."
 72 |   ([state side card] (install-cost state side card nil nil))
 73 |   ([state side card args] (install-cost state side card args nil))
 74 |   ([state side card {:keys [cost-bonus]} & targets]
 75 |    (->> [(when (runner? card)\
 76 |            (:cost card))\
 77 |          (or cost-bonus 0)\
 78 |          (when-let [instfun (:install-cost-bonus (card-def card))]\
 79 |            (instfun state side (make-eid state) card nil))\
 80 |          (sum-effects state side :install-cost card targets)]
 81 |         (reduce (fnil + 0 0))
 82 |         (max 0))))
 83 |
 84 | (defn install-additional-cost-bonus
 85 |   [state side card]
 86 |   (merge-costs
 87 |     [(:additional-cost (card-def card))\
 88 |      (get-effects state side :install-additional-cost card)]))
 89 |
 90 | (defn ignore-install-cost?
 91 |   [state side card]
 92 |   (any-effects state side :ignore-install-cost true? card))
 93 |
 94 | (defn run-cost
 95 |   "Get a list of all costs required to run a server."
 96 |   ([state side card] (run-cost state side card nil nil))
 97 |   ([state side card args] (run-cost state side card args nil))
 98 |   ([state side card {:keys [cost-bonus]} & targets]
 99 |    (->> [(or cost-bonus 0)\
100 |          (sum-effects state side :run-cost card targets)]
101 |         (reduce (fnil + 0 0))
102 |         (max 0))))
103 |
104 | (defn run-additional-cost-bonus
105 |   ([state side card] (run-additional-cost-bonus state side card nil))
106 |   ([state side card & targets]
107 |    (merge-costs
108 |      (get-effects state side :run-additional-cost card targets))))
109 |
110 | (defn has-trash-ability?
111 |   [card]
112 |   (let [abilities (:abilities (card-def card))\
113 |         prevents  (map :ability (:prevention (card-def card)))\
114 |         access-ab [(get-in (card-def card) [:interactions :access-ability])]\
115 |         events (:events (card-def card))]
116 |     (or (some :trash-icon (concat abilities events prevents access-ab))
117 |         (some #(= :trash-can (:cost/type %))
118 |               (->> (concat abilities events prevents access-ab)
119 |                    (map :cost)
120 |                    (vec)
121 |                    (merge-costs))))))
122 |
123 | (defn card-ability-cost
124 |   "Returns a list of all costs (printed and additional) required to use a given ability"
125 |   ([state side ability card] (card-ability-cost state side ability card nil))
126 |   ([state side ability card targets]
127 |    (let [base-cost [(:cost ability)\
128 |                     (when-let [cost-bonus-fn (:cost-bonus ability)]\
129 |                       (cost-bonus-fn state side (make-eid state) card targets))\
130 |                     (get-effects state side :card-ability-cost\
131 |                                  {:card card\
132 |                                   :ability ability\
133 |                                   :targets targets})]\
134 |          additional-cost (->> [(:additional-cost ability)\
135 |                                (get-effects state side :card-ability-additional-cost\
136 |                                             {:card card\
137 |                                              :ability ability\
138 |                                              :targets targets})]\
139 |                               (flatten)\
140 |                               ; TODO: uncomment when implementing additional costs\
141 |                               #_(keep #(when % (assoc % :cost/additional true))))]
142 |      (merge-costs (into base-cost additional-cost)))))
143 |
144 | (defn break-sub-ability-cost
145 |   ([state side ability card] (break-sub-ability-cost state side ability card nil))
146 |   ([state side ability card targets]
147 |    (merge-costs
148 |      [(:break-cost ability)\
149 |       (:additional-cost ability)\
150 |       (when-let [break-fn (:break-cost-bonus ability)]\
151 |         (break-fn state side (make-eid state) card targets))\
152 |       (get-effects state side :break-sub-additional-cost {:card card\
153 |                                                           :ability ability\
154 |                                                           :targets targets})])))
155 |
156 | (defn jack-out-cost
157 |   [state side]
158 |   (get-effects state side :jack-out-additional-cost))
159 |
160 | (defn steal-cost
161 |   "Gets a vector of costs and their sources for stealing the given agenda."
162 |   [state side eid card]
163 |   (let [steal-cost (when-let [costfun (:steal-cost-bonus (card-def card))]\
164 |                      (costfun state side eid card nil))\
165 |         steal-cost (when steal-cost\
166 |                      (if (map? steal-cost)\
167 |                        (assoc-in steal-cost [:cost/args :source] card)\
168 |                        (mapv #(assoc-in % [:cost/args :source] card) steal-cost)))\
169 |         ev (get-effect-value state side eid [card])]
170 |     (->> (get-effect-maps state side eid :steal-additional-cost [card])
171 |          (reduce
172 |            (fn [acc {ab-card :card :as ab}]
173 |              (let [cost (ev ab)\
174 |                    cost (if (map? cost)\
175 |                           (assoc-in cost [:cost/args :source] ab-card)\
176 |                           (mapv #(assoc-in % [:cost/args :source] ab-card) cost))]
177 |                (conj acc cost)))
178 |            [])
179 |          (concat [steal-cost])
180 |          (flatten)
181 |          (filter some?)
182 |          (mapv #(-> %
183 |                     (assoc :cost/additional true)
184 |                     (assoc-in [:cost/args :source-type] :ability))))))
185 |

--------------------------------------------------------------------------------
/src/clj/game/core/damage.clj:
--------------------------------------------------------------------------------
  1 | (ns game.core.damage
  2 |   (:require
  3 |     [game.core.card :refer [get-title]]
  4 |     [game.core.eid :refer [complete-with-result effect-completed make-eid]]
  5 |     [game.core.engine :refer [checkpoint queue-event trigger-event trigger-event-simult]]
  6 |     [game.core.moving :refer [trash-cards get-trash-event]]
  7 |     [game.core.prevention :refer [resolve-damage-prevention]]
  8 |     [game.core.prompt-state :refer [add-to-prompt-queue remove-from-prompt-queue]]
  9 |     [game.core.prompts :refer [clear-wait-prompt show-prompt show-wait-prompt]]
 10 |     [game.core.say :refer [system-msg]]
 11 |     [game.core.winning :refer [flatline]]
 12 |     [game.macros :refer [wait-for]]
 13 |     [game.utils :refer [dissoc-in enumerate-str side-str]]
 14 |     [jinteki.utils :refer [str->int]]))
 15 |
 16 | (defn damage-name [damage-type]
 17 |   (case damage-type
 18 |     :net "net"
 19 |     :meat "meat"
 20 |     :core "core"
 21 |     :brain "core"
 22 |     "[UNKNOWN DAMAGE TYPE]"))
 23 |
 24 | (defn enable-runner-damage-choice
 25 |   [state _]
 26 |   (swap! state assoc-in [:damage :damage-choose-runner] true))
 27 |
 28 | (defn enable-corp-damage-choice
 29 |   [state _]
 30 |   (swap! state assoc-in [:damage :damage-choose-corp] true))
 31 |
 32 | (defn runner-can-choose-damage?
 33 |   [state]
 34 |   (get-in @state [:damage :damage-choose-runner]))
 35 |
 36 | (defn corp-can-choose-damage?
 37 |   [state]
 38 |   (get-in @state [:damage :damage-choose-corp]))
 39 |
 40 | (defn chosen-damage
 41 |   [state _ & targets]
 42 |   (swap! state update-in [:damage :chosen-damage] #(apply conj % (flatten targets))))
 43 |
 44 | (defn- get-chosen-damage
 45 |   [state]
 46 |   (get-in @state [:damage :chosen-damage]))
 47 |
 48 | (defn- damage-choice-priority
 49 |   "Determines which side gets to act if either or both have the ability to choose cards for damage.
 50 |   Currently just for Chronos Protocol vs Titanium Ribs"
 51 |   [state]
 52 |   (let [active-player (get-in @state [:active-player])]
 53 |     (when (and (corp-can-choose-damage? state) (runner-can-choose-damage? state))
 54 |       (if (= active-player :corp)
 55 |         (swap! state update-in [:damage] dissoc :damage-choose-runner)
 56 |         (swap! state update-in [:damage] dissoc :damage-choose-corp)))))
 57 |
 58 | (defn- resolve-damage
 59 |   "Resolves the attempt to do n damage, now that both sides have acted to boost or
 60 |   prevent damage."
 61 |   [state side eid dmg-type n {:keys [card cause suppress-checkpoint]}]
 62 |   (swap! state dissoc-in [:damage :chosen-damage])
 63 |   (damage-choice-priority state)
 64 |   (wait-for (trigger-event-simult state side :pre-resolve-damage nil dmg-type side n)
 65 |             (if (not (pos? n))
 66 |               (do ;; shouldn't be possible, should be handled before getting here
 67 |                 (println "attempted to resolve 0 damage")
 68 |                 (effect-completed state side eid))
 69 |               (let [hand (get-in @state [:runner :hand])\
 70 |                     chosen-cards (seq (get-chosen-damage state))\
 71 |                     chosen-cids (into #{} (map :cid chosen-cards))\
 72 |                     leftovers (remove #(contains? chosen-cids (:cid %)) hand)\
 73 |                     cards-trashed (->> (shuffle leftovers)\
 74 |                                        (take (- n (count chosen-cards)))\
 75 |                                        (concat chosen-cards))]
 76 |                 (when (= dmg-type :brain)
 77 |                   (swap! state update-in [:runner :brain-damage] #(+ % n)))
 78 |                 (when-let [trashed-msg (enumerate-str (map get-title cards-trashed))]
 79 |                   (system-msg state :runner (str "trashes " trashed-msg " due to " (damage-name dmg-type) " damage"))
 80 |                   (swap! state update-in [:stats :corp :damage :all] (fnil + 0) n)
 81 |                   (swap! state update-in [:stats :corp :damage dmg-type] (fnil + 0) n)
 82 |                   (if (< (count hand) n)
 83 |                     (do (flatline state)
 84 |                         (trash-cards state side eid cards-trashed {:unpreventable true}))
 85 |                     (wait-for (trash-cards state side cards-trashed {:unpreventable true
 86 |                                                                      :cause dmg-type
 87 |                                                                      :suppress-checkpoint true
 88 |                                                                      :suppress-event true})
 89 |                               (queue-event state :damage {:amount n
 90 |                                                           :card card
 91 |                                                           :damage-type dmg-type
 92 |                                                           :cause cause
 93 |                                                           :cards-trashed cards-trashed})
 94 |                               (if suppress-checkpoint
 95 |                                 (complete-with-result state side eid cards-trashed)
 96 |                                 (let [trash-event (get-trash-event side false)\
 97 |                                       args {:durations [:damage trash-event]}]
 98 |                                   (wait-for (checkpoint state nil (make-eid state eid) args)
 99 |                                             (complete-with-result state side eid cards-trashed)))))))))))
100 |
101 | (defn damage
102 |   "Attempts to deal n damage of the given type to the runner. Starts the
103 |   prevention/boosting process and eventually resolves the damage."
104 |   ([state side eid type n] (damage state side eid type n nil))
105 |   ([state side eid type n {:keys [unpreventable card suppress-checkpoint] :as args}]
106 |    (wait-for (resolve-damage-prevention state side type n args)
107 |              (let [{:keys [remaining type source-card]} async-result]
108 |                (if (pos? remaining)
109 |                  (resolve-damage state side eid type remaining (assoc args :card source-card))
110 |                  (do (queue-event state :all-damage-was-prevented {:side side
111 |                                                                    :type type
112 |                                                                    :cause-card source-card})
113 |                      (if suppress-checkpoint
114 |                        (effect-completed state side eid)
115 |                        (checkpoint state side eid))))))))
116 |

--------------------------------------------------------------------------------
/src/clj/game/core/drawing.clj:
--------------------------------------------------------------------------------
  1 | (ns game.core.drawing
  2 |   (:require
  3 |     [game.core.card :refer [get-title]]
  4 |     [game.core.eid :refer [effect-completed make-eid make-result]]
  5 |     [game.core.engine :refer [checkpoint queue-event resolve-ability trigger-event trigger-event-simult trigger-event-sync]]
  6 |     [game.core.events :refer [first-event?]]
  7 |     [game.core.flags :refer [prevent-draw]]
  8 |     [game.core.moving :refer [move]]
  9 |     [game.core.say :refer [system-msg]]
 10 |     [game.core.set-aside :refer [set-aside-for-me get-set-aside]]
 11 |     [game.core.winning :refer [win-decked]]
 12 |     [game.macros :refer [continue-ability msg req wait-for]]
 13 |     [game.utils :refer [quantify safe-zero?]]
 14 |     [jinteki.utils :refer [other-side]]))
 15 |
 16 | (defn max-draw
 17 |   "Put an upper limit on the number of cards that can be drawn in this turn."
 18 |   [state side n]
 19 |   (swap! state assoc-in [side :register :max-draw] n))
 20 |
 21 | (defn remaining-draws
 22 |   "Calculate remaining number of cards that can be drawn this turn if a maximum exists"
 23 |   [state side]
 24 |   (when-let [max-draw (get-in @state [side :register :max-draw])]
 25 |     (let [drawn-this-turn (get-in @state [side :register :drawn-this-turn] 0)]
 26 |       (max (- max-draw drawn-this-turn) 0))))
 27 |
 28 | (defn draw-bonus
 29 |   "Registers a bonus of n draws to the next draw (Daily Business Show)"
 30 |   [state _ n]
 31 |   (swap! state update-in [:bonus :draw] (fnil #(+ % n) 0)))
 32 |
 33 | (defn click-draw-bonus
 34 |   "Registers a bonus of n draws to the next draw done by a click (Laguna Velasco District)"
 35 |   [state _ n]
 36 |   (swap! state update-in [:bonus :click-draw] (fnil #(+ % n) 0)))
 37 |
 38 | (defn use-bonus-click-draws!
 39 |   "Returns value of click-draw bonus and reset it"
 40 |   [state]
 41 |   (let [bonus-click-draws (get-in @state [:bonus :click-draw] 0)]
 42 |     (swap! state update :bonus dissoc :click-draw)
 43 |     bonus-click-draws))
 44 |
 45 | (defn first-time-draw-bonus
 46 |   [side n]
 47 |   (let [event (keyword (str "pre-" (name side) "-draw"))]
 48 |     {:event event
 49 |      :msg "draw 1 additional card"
 50 |      ;; The req catches draw events that happened before the card was installed
 51 |      :req (req (first-event? state side event))
 52 |      :once :per-turn
 53 |      :effect (req (draw-bonus state side n))}))
 54 |
 55 | (defn draw
 56 |   "Draw n cards from :deck to :hand."
 57 |   ([state side eid n] (draw state side eid n nil))
 58 |   ([state side eid n {:keys [suppress-event no-update-draw-stats]}]
 59 |    (if (zero? n)
 60 |      (effect-completed state side eid)
 61 |      (wait-for (trigger-event-simult state side (make-eid state eid) (if (= side :corp) :pre-corp-draw :pre-runner-draw) nil n)
 62 |        (let [n (+ n (get-in @state [:bonus :draw] 0))\
 63 |              draws-wanted n\
 64 |              active-player (get-in @state [:active-player])\
 65 |              draws-after-prevent (if (and (= side active-player) (get-in @state [active-player :register :max-draw]))\
 66 |                                    (min n (remaining-draws state side))\
 67 |                                    n)\
 68 |              deck-count (count (get-in @state [side :deck]))]
 69 |          (swap! state update :bonus dissoc :draw);; clear bonus draws
 70 |          (when (and (= side :corp) (< deck-count draws-after-prevent))
 71 |            (win-decked state))
 72 |          (when (< draws-after-prevent draws-wanted)
 73 |            (let [prevented (- draws-wanted draws-after-prevent)]
 74 |              (system-msg state (other-side side)
 75 |                          (str "prevents " (quantify prevented "card") " from being drawn"))))
 76 |          (if (or (and (= side active-player)
 77 |                       (get-in @state [side :register :cannot-draw]))
 78 |                  (not (pos? draws-after-prevent))
 79 |                  (not (pos? deck-count)))
 80 |            (effect-completed state side eid)
 81 |            (let [to-draw (take draws-after-prevent (get-in @state [side :deck]))\
 82 |                  set-aside-eid eid]
 83 |              (let [drawn (set-aside-for-me state side set-aside-eid to-draw)\
 84 |                    drawn-count (count drawn)]
 85 |                (swap! state update-in [side :register :drawn-this-turn] (fnil #(+ % drawn-count) 0))
 86 |                (if (not no-update-draw-stats)
 87 |                  (swap! state update-in [:stats side :gain :card] (fnil + 0) n))
 88 |                (if suppress-event
 89 |                  (do
 90 |                    (doseq [c (get-set-aside state side set-aside-eid)]
 91 |                      (move state side c :hand))
 92 |                    (effect-completed state side eid))
 93 |                  (let [draw-event (if (= side :corp) :corp-draw :runner-draw)]
 94 |                    (swap! state update-in [side :register :currently-drawing] conj drawn)
 95 |                    (queue-event state draw-event {:cards drawn
 96 |                                                   :count drawn-count})
 97 |                    (wait-for
 98 |                      (checkpoint state nil (make-eid state eid) nil)
 99 |                      (doseq [c (get-set-aside state side set-aside-eid)]
100 |                        (move state side c :hand))
101 |                      (wait-for (trigger-event-sync state side (make-eid state eid) (if (= side :corp) :post-corp-draw :post-runner-draw) drawn-count)
102 |                                (let [eid (make-result eid (-> @state side :register :currently-drawing (peek)))]
103 |                                  (swap! state update-in [side :register :currently-drawing] pop)
104 |                                  (effect-completed state side eid))))))
105 |                (when (safe-zero? (remaining-draws state side))
106 |                  (prevent-draw state side))))))))))
107 |
108 | (defn maybe-draw
109 |   ([state side eid card n] (maybe-draw state side eid card n nil))
110 |   ([state side eid card n args]
111 |    (if (zero? n)
112 |      (draw state side eid n args)
113 |      (continue-ability
114 |        state side
115 |        {:optional {:prompt (str "Draw " (quantify n "card") "?")
116 |                    :yes-ability {:async true
117 |                                  :msg (msg "draw " (quantify n " card"))
118 |                                  :effect (req (draw state side eid n))}
119 |                    :no-ability {:effect (req (system-msg state side (str "declines to use " (get-title card) " to draw cards")))}}}
120 |        card nil))))
121 |
122 | (defn draw-up-to
123 |   ([state side eid card n] (draw-up-to state side eid card n {:allow-zero-draws true}))
124 |   ([state side eid card n {:keys [allow-zero-draws] :as args}]
125 |    (if (zero? n)
126 |      (draw state side eid 0 args)
127 |      (continue-ability
128 |        state side
129 |        {:prompt (str "Draw how many cards?" (when-not allow-zero-draws " (minimum 1)"))
130 |         :choices {:number (req n)
131 |                   :max (req n)
132 |                   :default (req n)}
133 |         :waiting-prompt true
134 |         :async true
135 |         :msg (msg "draw " (quantify (or target 0) "card"));
136 |         :effect (req
137 |                   (if (and (not target) (not allow-zero-draws))
138 |                     (draw-up-to state side (make-eid state eid) n args)
139 |                     (draw state side eid target args)))}
140 |        card nil))))
141 |

--------------------------------------------------------------------------------
/src/clj/game/core/effects.clj:
--------------------------------------------------------------------------------
  1 | (ns game.core.effects
  2 |   (:require [clj-uuid :as uuid]
  3 |             [game.core.card :refer [facedown? get-card runner?]]
  4 |             [game.core.card-defs :refer [card-def]]
  5 |             [game.core.eid :refer [make-eid]]
  6 |             [game.core.board :refer [get-all-cards]]
  7 |             [game.utils :refer [remove-once same-card? to-keyword]]))
  8 |
  9 | (defn is-disabled-reg?
 10 |   [state card]
 11 |   (get (:disabled-card-reg @state) (:cid card)))
 12 |
 13 | (defn gather-effects
 14 |   [state _ effect-type]
 15 |   (let [get-side #(-> % :card :side to-keyword)\
 16 |         is-active-player #(= (:active-player @state) (get-side %))]
 17 |     (->> (:effects @state)
 18 |          (filter #(= effect-type (:type %)))
 19 |          (filter #(not (and (:static %) (is-disabled-reg? state (:card %)))))
 20 |          (sort-by (complement is-active-player))
 21 |          (into []))))
 22 |
 23 | (defn update-effect-card
 24 |   "Updates the effect map's :card with the result of `get-card`."
 25 |   [state ability]
 26 |   (update ability :card #(get-card state %)))
 27 |
 28 | (defn effect-pred
 29 |   "Returns a function that returns the boolean result of the :req on the effect map.
 30 |   If the :req is an fn, it is called with the given state, side, eid, and targets,
 31 |   and the effect map's card. Otherwise, return true."
 32 |   [state side eid targets]
 33 |   (fn [{:keys [req card]}]
 34 |     (if (fn? req)
 35 |       (boolean (req state side eid card targets))
 36 |       true)))
 37 |
 38 | (defn get-effect-maps
 39 |   "Returns the filtered effects for a given effect type. Updates the :card before
 40 |   filtering, so the :card might be nil."
 41 |   ([state side effect-type] (get-effect-maps state side (make-eid state) effect-type nil))
 42 |   ([state side eid effect-type] (get-effect-maps state side eid effect-type nil))
 43 |   ([state side eid effect-type targets]
 44 |    (->> (gather-effects state side effect-type)
 45 |         (map #(update-effect-card state %))
 46 |         (filterv (effect-pred state side eid targets)))))
 47 |
 48 | (defn get-effect-value
 49 |   "Returns a function that returns the value of a given effect. If the :value is an fn,
 50 |   it is called with the given state, side, eid, and targets. Otherwise, return the raw
 51 |   value."
 52 |   ([state side] (get-effect-value state side (make-eid state) nil))
 53 |   ([state side eid] (get-effect-value state side eid nil))
 54 |   ([state side eid targets]
 55 |    (fn [{:keys [value card]}]
 56 |      (if (fn? value)
 57 |        (value state side eid card targets)
 58 |        value))))
 59 |
 60 | (defn get-effects
 61 |   "Filters and then 'executes' the effects of a given type."
 62 |   ([state side effect-type] (get-effects state side effect-type nil nil))
 63 |   ([state side effect-type target] (get-effects state side effect-type target nil))
 64 |   ([state side effect-type target targets]
 65 |    (let [eid (make-eid state)\
 66 |          targets (cons target targets)]
 67 |      (->> (get-effect-maps state side eid effect-type targets)
 68 |           (mapv (get-effect-value state side eid targets))))))
 69 |
 70 | (defn sum-effects
 71 |   "Sums the results from get-effects."
 72 |   ([state side effect-type] (sum-effects state side effect-type nil nil))
 73 |   ([state side effect-type target] (sum-effects state side effect-type target nil))
 74 |   ([state side effect-type target targets]
 75 |    (->> (get-effects state side effect-type target targets)
 76 |         (filter number?)
 77 |         (reduce + 0))))
 78 |
 79 | (defn any-effects
 80 |   "Check if any effects return true for pred"
 81 |   ([state side effect-type] (any-effects state side effect-type true? nil nil))
 82 |   ([state side effect-type pred] (any-effects state side effect-type pred nil nil))
 83 |   ([state side effect-type pred target] (any-effects state side effect-type pred target nil))
 84 |   ([state side effect-type pred target targets]
 85 |    (some pred (get-effects state side effect-type target targets))))
 86 |
 87 | (defn is-disabled?
 88 |   "Check if a card is disabled"
 89 |   ([state side target]
 90 |    (any-effects state side :disable-card true? target)))
 91 |
 92 | (defn all-disabled-cards
 93 |   "Gets all cards currently disabled"
 94 |   [state]
 95 |   (let [all-cards (get-all-cards state)\
 96 |         disabled-cards (filter #(or (is-disabled? state nil %)\
 97 |                                     (and (runner? %) (facedown? %)))\
 98 |                                all-cards)]
 99 |     (into {} (map (juxt :cid identity)) disabled-cards)))
100 |
101 | (defn update-disabled-cards [state]
102 |   (swap! state assoc :disabled-card-reg (all-disabled-cards state))
103 |   (:disabled-card-reg @state))
104 |
105 | (defn register-static-abilities
106 |   [state _ card]
107 |   (when (:static-abilities (card-def card))
108 |     (let [static-abilities (:static-abilities (card-def card))\
109 |           abilities (for [ability static-abilities]\
110 |                       (assoc\
111 |                         (select-keys ability [:type :req :value])\
112 |                         ;; this is so I can select them later\
113 |                         :static true\
114 |                         :duration :while-active\
115 |                         :card card\
116 |                         :uuid (uuid/v1)))]
117 |       (swap! state update :effects
118 |              #(apply conj (into [] %) abilities))
119 |       (update-disabled-cards state)
120 |       abilities)))
121 |
122 | (defn unregister-static-abilities
123 |   [state _ card]
124 |   (swap! state assoc :effects
125 |          (->> (:effects @state)
126 |               (remove #(and (same-card? card (:card %))
127 |                             (= :while-active (:duration %))))
128 |               (into [])))
129 |   (update-disabled-cards state))
130 |
131 | (defn register-lingering-effect
132 |   [state _ card ability]
133 |   (let [ability (assoc\
134 |                   (select-keys ability [:type :duration :req :value])\
135 |                   :card card\
136 |                   :lingering true\
137 |                   :uuid (uuid/v1))]
138 |     (swap! state update :effects conj ability)
139 |     (update-disabled-cards state)
140 |     ability))
141 |
142 | (defn unregister-effect-by-uuid
143 |   "Removes a single effect handler with matching uuid"
144 |   [state _ {:keys [uuid] :as ability}]
145 |   (swap! state assoc :effects (remove-once #(= uuid (:uuid %)) (:effects @state))))
146 |
147 | (defn update-lingering-effect-durations
148 |   "updates all effects with a given duration to have another duration
149 |    ie: :until-next-corp-turn-begins -> :until-corp-turn-begins"
150 |   [state _ from-key to-key]
151 |   (swap! state assoc :effects
152 |          (->> (:effects @state)
153 |               (map #(if (= (:duration %) from-key) (assoc % :duration to-key) %))
154 |               (into [])))
155 |   (update-disabled-cards state))
156 |
157 | (defn unregister-lingering-effects
158 |   [state _ duration]
159 |   (swap! state assoc :effects
160 |          (->> (:effects @state)
161 |               (remove #(= duration (:duration %)))
162 |               (into [])))
163 |   (update-disabled-cards state))
164 |
165 | (defn unregister-effects-for-card
166 |   ([state _ card] (unregister-effects-for-card state nil card identity))
167 |   ([state _ card pred]
168 |    (swap! state assoc :effects
169 |           (->> (:effects @state)
170 |                (remove #(and (same-card? card (:card %))
171 |                              (pred %)))
172 |                (into [])))
173 |    (update-disabled-cards state)))
174 |

--------------------------------------------------------------------------------
/src/clj/game/core/eid.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.eid
 2 |   (:require
 3 |     [medley.core :refer [find-first]]
 4 |     [game.core.card :refer [basic-action?]]
 5 |     [game.core.prompt-state :refer [remove-from-prompt-queue]]))
 6 |
 7 | (defn make-eid
 8 |   ([state] (make-eid state nil))
 9 |   ([state existing-eid]
10 |    (assoc existing-eid :eid (:eid (swap! state update :eid inc)))))
11 |
12 | (defn get-ability-targets
13 |   [eid]
14 |   (get-in eid [:source-info :ability-targets 0]))
15 |
16 | (defn is-basic-advance-action?
17 |   [eid]
18 |   (and (basic-action? (:source eid))
19 |        (= 4 (get-in eid [:source-info :ability-idx]))))
20 |
21 | (defn register-effect-completed
22 |   [state eid effect]
23 |   (if (get-in @state [:effect-completed (:eid eid)])
24 |     (throw (ex-info "Eid has already been registered" eid))
25 |     (swap! state assoc-in [:effect-completed (:eid eid)] effect)))
26 |
27 | (defn clear-eid-wait-prompt
28 |   [state side eid]
29 |   (when-let [prompt (find-first #(and (= (:eid eid) (:eid (:eid %)))\
30 |                                       (= :waiting (:prompt-type %)))\
31 |                                 (get-in @state [side :prompt]))]
32 |     (remove-from-prompt-queue state side prompt)))
33 |
34 | (defn effect-completed
35 |   [state _ eid]
36 |   (doseq [side [:corp :runner]]
37 |     (clear-eid-wait-prompt state side eid))
38 |   (when-let [handler (get-in @state [:effect-completed (:eid eid)])]
39 |     (handler eid)
40 |     (swap! state update :effect-completed dissoc (:eid eid)))
41 |   nil)
42 |
43 | (defn make-result
44 |   [eid result]
45 |   (assoc eid :result result))
46 |
47 | (defn complete-with-result
48 |   "Calls `effect-complete` with `make-result` and also returns the argument"
49 |   [state side eid result]
50 |   (effect-completed state side (make-result eid result))
51 |   nil)
52 |

--------------------------------------------------------------------------------
/src/clj/game/core/events.clj:
--------------------------------------------------------------------------------
  1 | (ns game.core.events
  2 |   (:require
  3 |     [game.core.card :refer [installed?]]
  4 |     [game.utils :refer [side-str]]))
  5 |
  6 | ;; Functions for event parsing
  7 | (defn turn-events
  8 |   "Returns the targets vectors of each event with the given key that was triggered this turn."
  9 |   [state _ ev]
 10 |   (mapcat rest (filter #(= ev (first %)) (:turn-events @state))))
 11 |
 12 | (defn last-turn?
 13 |   [state side event]
 14 |   (get-in @state [side :register-last-turn event]))
 15 |
 16 | (defn not-last-turn?
 17 |   [state side event]
 18 |   (cond
 19 |     ; Return false if no previous turn (i.e. turn 1).
 20 |     (-> @state side :register-last-turn nil?) false
 21 |     (-> @state side :register-last-turn event) false
 22 |     :else true))
 23 |
 24 | (defn no-event?
 25 |   "Returns true if the given event has not happened yet this turn.
 26 |   Filters on events satisfying (pred targets) if given pred."
 27 |   ([state side ev] (no-event? state side ev (constantly true)))
 28 |   ([state side ev pred]
 29 |    (empty? (filter pred (turn-events state side ev)))))
 30 |
 31 | (defn event-count
 32 |   "Returns the number of an event this turn."
 33 |   ([state side ev] (event-count state side ev (constantly true)))
 34 |   ([state side ev pred]
 35 |    (count (filter pred (turn-events state side ev)))))
 36 |
 37 | (defn first-event?
 38 |   "Returns true if the given event has only occured once this turn.
 39 |   Includes itself if this is checked in the requirement for an event ability.
 40 |   Filters on events satisfying (pred targets) if given pred."
 41 |   ([state side ev] (first-event? state side ev (constantly true)))
 42 |   ([state side ev pred]
 43 |    (= 1 (event-count state side ev pred))))
 44 |
 45 | (defn second-event?
 46 |   "Returns true if the given event has occurred twice this turn.
 47 |   Includes itself if this is checked in the requirement for an event ability.
 48 |   Filters on events satisfying (pred targets) if given pred."
 49 |   ([state side ev] (second-event? state side ev (constantly true)))
 50 |   ([state side ev pred]
 51 |    (= 2 (event-count state side ev pred))))
 52 |
 53 | (defn first-successful-run-on-server?
 54 |   "Returns true if the active run is the first succesful run on the given server"
 55 |   [state server]
 56 |   (first-event? state :runner :successful-run #(= [server] (:server (first %)))))
 57 |
 58 | (defn first-trash?
 59 |   "Returns true if cards have been trashed by either player only once this turn.
 60 |   Includes itself if this is checked in the requirement for an event ability.
 61 |   Filters on trash events satisfying (pred targets) if given pred.
 62 |   Note that trash event targets may be optionally followed by a reason for the trash, or nil."
 63 |   ([state] (first-trash? state (constantly true)))
 64 |   ([state pred]
 65 |    (= 1 (+ (event-count state nil :runner-trash pred)
 66 |            (event-count state nil :corp-trash pred)
 67 |            (event-count state nil :game-trash pred)))))
 68 |
 69 | (defn get-turn-damage
 70 |   "Returns the value of damage take this turn"
 71 |   [state _]
 72 |   (apply + (keep #(:amount (first %)) (turn-events state :runner :damage))))
 73 |
 74 | (defn get-installed-trashed
 75 |   "Returns list of cards trashed this turn owned by side that were installed"
 76 |   [state side]
 77 |   (->> (turn-events state side (if (= :corp side) :corp-trash :runner-trash))
 78 |        (mapcat (fn [targets] (filter #(installed? (:card %)) targets)))))
 79 |
 80 | (defn first-installed-trash?
 81 |   "Returns true if this is the first trash of an installed card this turn by this side"
 82 |   [state side]
 83 |   (= 1 (count (get-installed-trashed state side))))
 84 |
 85 | (defn first-installed-trash-own?
 86 |   "Returns true if this is the first trash of an owned installed card this turn by this side"
 87 |   [state side]
 88 |   (= 1 (count (filter #(= (:side (:card %)) (side-str side)) (get-installed-trashed state side)))))
 89 |
 90 |
 91 | ;; Functions for run event parsing
 92 | (defn run-events
 93 |   "Returns the targets vectors of each run event with the given key that was triggered this run."
 94 |   ([state _ ev]
 95 |    (when (:run @state)
 96 |      (run-events (:run @state) ev)))
 97 |   ([run ev]
 98 |    (mapcat rest (filter #(= ev (first %)) (:events run)))))
 99 |
100 | (defn no-run-event?
101 |   "Returns true if the given run event has not happened yet this run.
102 |   Filters on run events satisfying (pred targets) if given pred."
103 |   ([state side ev] (no-run-event? state side ev (constantly true)))
104 |   ([state side ev pred]
105 |    (empty? (filter pred (run-events state side ev)))))
106 |
107 | (defn run-event-count
108 |   "Returns the number of times a run event has happened this run."
109 |   ([state side ev] (run-event-count state side ev (constantly true)))
110 |   ([state side ev pred]
111 |    (count (filter pred (run-events state side ev)))))
112 |
113 | (defn first-run-event?
114 |   "Returns true if the given run event has only occured once this run.
115 |   Includes itself if this is checked in the requirement for a run event ability.
116 |   Filters on run events satisfying (pred targets) if given pred."
117 |   ([state side ev] (first-run-event? state side ev (constantly true)))
118 |   ([state side ev pred]
119 |    (= 1 (run-event-count state side ev pred))))
120 |

--------------------------------------------------------------------------------
/src/clj/game/core/expend.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.expend
 2 |   (:require
 3 |    [game.core.card-defs :refer [card-def]]
 4 |    [game.core.effects :refer [is-disabled-reg?]]
 5 |    [game.core.engine :refer [checkpoint queue-event resolve-ability]]
 6 |    [game.core.payment :refer [can-pay? merge-costs ->c]]
 7 |    [game.macros :refer [req wait-for]]))
 8 |
 9 | (defn expendable?
10 |   "Can a card be expended? (disabled cards will not retain the ability)"
11 |   [state card]
12 |   (and (:expend (card-def card)) (not (is-disabled-reg? state card))))
13 |
14 | (defn expend
15 |   [ex]
16 |   (let [exp-cost [(->c :click 1) (->c :expend)]\
17 |         merged-cost (if (some? (:cost ex))\
18 |                       (merge-costs (conj (:cost ex) exp-cost))\
19 |                       exp-cost)]
20 |     {:req (req
21 |             (and
22 |               (can-pay?
23 |                 state side (assoc eid :source card :source-type :ability) card nil merged-cost)
24 |               (if (some? (:req ex))
25 |                 ((:req ex) state side eid card targets)
26 |                 true)))
27 |      :async true
28 |      :action true
29 |      :effect (req
30 |                (wait-for
31 |                  (resolve-ability state :corp (assoc ex :cost merged-cost) card nil)
32 |                  (queue-event state :expend-resolved {:card card})
33 |                  (checkpoint state nil eid nil)))}))
34 |

--------------------------------------------------------------------------------
/src/clj/game/core/expose.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.expose
 2 |   (:require
 3 |     [game.core.card :refer [rezzed?]]
 4 |     [game.core.card-defs :refer [card-def]]
 5 |     [game.core.eid :refer [complete-with-result effect-completed make-eid make-result]]
 6 |     [game.core.effects :refer [any-effects]]
 7 |     [game.core.engine :refer [checkpoint queue-event register-pending-event resolve-ability trigger-event-sync]]
 8 |     [game.core.prevention :refer [resolve-expose-prevention]]
 9 |     [game.core.prompts :refer [clear-wait-prompt show-prompt show-wait-prompt]]
10 |     [game.core.say :refer [system-msg]]
11 |     [game.core.to-string :refer [card-str]]
12 |     [game.utils :refer [enumerate-str]]
13 |     [game.macros :refer [wait-for]]))
14 |
15 | (defn resolve-expose
16 |   [state side eid targets {:keys [card] :as args}]
17 |   (if-not (seq targets)
18 |     (effect-completed state side eid)
19 |     (do (system-msg state side (str (if-not card "exposes " (str "uses " (:title card) " to expose ")) (enumerate-str (map #(card-str state % {:visible true}) targets))))
20 |         (doseq [t targets]
21 |           (when-let [ability (:on-expose (card-def t))]
22 |             ;; if it gets rezzed by blackguard or something, the effect shouldn't fizzle
23 |             (register-pending-event state :expose t (assoc ability :condition :installed))))
24 |         (queue-event state :expose {:cards targets})
25 |         (wait-for (checkpoint state side {:duration :expose})
26 |                   (complete-with-result state side eid {:cards targets})))))
27 |
28 | (defn expose
29 |   "Exposes the given cards."
30 |   ([state side eid targets] (expose state side eid targets nil))
31 |   ([state side eid targets {:keys [unpreventable] :as args}]
32 |    (let [args (assoc args :card (:source eid))\
33 |          targets (filterv #(not (or (rezzed? %)\
34 |                                     (nil? %)\
35 |                                     (any-effects state side :cannot-be-exposed true? %)))\
36 |                           targets)]
37 |      (if (empty? targets)
38 |        (effect-completed state side eid) ;; cannot expose faceup cards
39 |        (wait-for (resolve-expose-prevention state side targets args)
40 |                  (resolve-expose state side eid (:remaining async-result) args))))))
41 |

--------------------------------------------------------------------------------
/src/clj/game/core/finding.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.finding
 2 |   (:require [game.core.board :refer [all-installed]]
 3 |             [game.utils :refer [to-keyword]]))
 4 |
 5 | ;;; Functions for loading card information.
 6 | (defn find-card
 7 |   "Return a card with given title from given sequence"
 8 |   [title from]
 9 |   (some #(when (= (:title %) title) %) from))
10 |
11 | (defn find-cid
12 |   "Return a card with specific :cid from given sequence"
13 |   [cid from]
14 |   (some #(when (= (:cid %) cid) %) from))
15 |
16 | (defn find-latest
17 |   "Returns the newest version of a card where-ever it may be"
18 |   [state card]
19 |   (find-cid (:cid card) (concat (all-installed state (-> card :side to-keyword))
20 |                                 (-> (map #(get-in @state [:corp %]) [:hand :discard :deck :rfg :scored]) concat flatten)
21 |                                 (-> (map #(get-in @state [:runner %]) [:hand :discard :deck :rfg :scored]) concat flatten))))
22 |
23 | (defn get-scoring-owner
24 |   "Returns the owner of the scoring area the card is in"
25 |   [state {:keys [cid]}]
26 |   (cond
27 |     (find-cid cid (get-in @state [:corp :scored]))
28 |     :corp
29 |     (find-cid cid (get-in @state [:runner :scored]))
30 |     :runner))
31 |

--------------------------------------------------------------------------------
/src/clj/game/core/gaining.clj:
--------------------------------------------------------------------------------
  1 | (ns game.core.gaining
  2 |   (:require
  3 |     [game.core.eid :refer [effect-completed]]
  4 |     [game.core.engine :refer [trigger-event trigger-event-sync queue-event checkpoint]]))
  5 |
  6 | (defn safe-inc-n
  7 |   "Helper function to safely update a value by n. Returns a function to use with `update` / `update-in`"
  8 |   [n]
  9 |   (partial (fnil + 0 0) n))
 10 |
 11 | (defn sub->0
 12 |   "Helper function for use in `update` or `update-in` to subtract for a value, to a minimum of 0."
 13 |   [n]
 14 |   #(max 0 ((fnil - 0 0) % n)))
 15 |
 16 | (defn deduct
 17 |   "Deduct the value from the player's attribute."
 18 |   [state side [attr value]]
 19 |   (cond
 20 |     ;; value is a map, should be :base, :mod, etc.
 21 |     (map? value)
 22 |     (doseq [[subattr value] value]
 23 |       (swap! state update-in [side attr subattr] (if (#{:mod :used} subattr)
 24 |                                                    ;; Modifications and mu used may be negative
 25 |                                                    ;; mu used is for easier implementation of the 0-mu hosting things
 26 |                                                    #(- % value)
 27 |                                                    (sub->0 value))))
 28 |
 29 |     ;; values that expect map, if passed a number use default subattr of :mod
 30 |     (#{:memory} attr)
 31 |     (deduct state side [attr {:mod value}])
 32 |
 33 |     ;; default case for tags and bad-publicity is `:base`
 34 |     (#{:tag :bad-publicity} attr)
 35 |     (deduct state side [attr {:base value}])
 36 |
 37 |     :else
 38 |     (do (swap! state update-in [side attr] (if (= attr :agenda-point)
 39 |                                              ;; Agenda points may be negative
 40 |                                              #(- % value)
 41 |                                              (sub->0 value)))
 42 |         (when (and (= attr :credit)
 43 |                    (= side :runner)
 44 |                    (pos? (get-in @state [:runner :run-credit] 0)))
 45 |           (swap! state update-in [:runner :run-credit] (sub->0 value))))))
 46 |
 47 | (defn gain [state side & args]
 48 |   (doseq [[cost-type amount] (partition 2 args)]
 49 |     (cond
 50 |       ;; amount is a map, merge-update map
 51 |       (map? amount)
 52 |       (doseq [[subtype amount] amount]
 53 |         (swap! state update-in [side cost-type subtype] (safe-inc-n amount))
 54 |         (swap! state update-in [:stats side :gain cost-type subtype] (fnil + 0) amount))
 55 |
 56 |       ;; Default cases for the types that expect a map
 57 |       (#{:hand-size :memory} cost-type)
 58 |       (gain state side cost-type {:mod amount})
 59 |
 60 |       ;; Default case for tags and bad publicity is `:base`
 61 |       (#{:tag :bad-publicity} cost-type)
 62 |       (gain state side cost-type {:base amount})
 63 |
 64 |       ;; Else assume amount is a number and try to increment cost-type by it.
 65 |       :else
 66 |       (do (swap! state update-in [side cost-type] (safe-inc-n amount))
 67 |           (swap! state update-in [:stats side :gain cost-type] (fnil + 0 0) amount)))
 68 |     (trigger-event state side (if (= side :corp) :corp-gain :runner-gain) {:type cost-type
 69 |                                                                            :amount amount})))
 70 |
 71 | (defn lose [state side & args]
 72 |   (doseq [[cost-type amount] (partition 2 args)]
 73 |     (if (= amount :all)
 74 |       (do (swap! state update-in [:stats side :lose cost-type] (fnil + 0) (get-in @state [side cost-type]))
 75 |           (swap! state assoc-in [side cost-type] 0))
 76 |       (do (when (number? amount)
 77 |             (swap! state update-in [:stats side :lose cost-type] (fnil + 0) amount))
 78 |           (deduct state side [cost-type amount])))
 79 |     (trigger-event state side (if (= side :corp) :corp-lose :runner-lose) {:type cost-type
 80 |                                                                            :amount amount})))
 81 |
 82 | (defn gain-credits
 83 |   "Utility function for triggering events"
 84 |   ([state side eid amount] (gain-credits state side eid amount nil))
 85 |   ([state side eid amount {:keys [action suppress-checkpoint]}]
 86 |    (if (and amount
 87 |             (pos? amount))
 88 |      (let [event (if (= :corp side) :corp-credit-gain :runner-credit-gain)]
 89 |        (gain state side :credit amount)
 90 |        (queue-event state event {:side side
 91 |                                  :amount amount
 92 |                                  :action action})
 93 |        (if suppress-checkpoint
 94 |          (effect-completed state nil eid)
 95 |          (checkpoint state eid)))
 96 |      (effect-completed state side eid))))
 97 |
 98 | (defn lose-credits
 99 |   "Utility function for triggering events"
100 |   ([state side eid amount] (lose-credits state side eid amount nil))
101 |   ([state side eid amount args]
102 |    (if (and amount
103 |             (or (= :all amount)
104 |                 (pos? amount))
105 |             (pos? (:credit (side @state))))
106 |      (do (lose state side :credit amount)
107 |          (when (and (= side :runner)
108 |                     (= :all amount))
109 |            (lose state :runner :run-credit :all))
110 |          (trigger-event-sync state side eid (if (= :corp side) :corp-credit-loss :runner-credit-loss) amount args))
111 |      (effect-completed state side eid))))
112 |
113 | (defn gain-clicks
114 |   ([state side amount] (gain-clicks state side amount nil))
115 |   ([state side amount args]
116 |     (when (and amount
117 |                (pos? amount))
118 |       (gain state side :click amount)
119 |       (trigger-event state side (if (= :corp side) :corp-click-gain :runner-click-gain) {:amount amount
120 |                                                                                          :args args}))))
121 |
122 | (defn lose-clicks
123 |   ([state side amount] (lose-clicks state side amount nil))
124 |   ([state side amount args]
125 |     (when (and amount
126 |                (or (= :all amount)
127 |                    (pos? amount)))
128 |       (lose state side :click amount)
129 |       (trigger-event state side (if (= :corp side) :corp-click-loss :runner-click-loss) {:amount amount
130 |                                                                                          :args args}))))
131 |
132 | ;;; Stuff for handling {:base x :mod y} data structures
133 | (defn base-mod-size
134 |   "Returns the value of properties using the `base` and `mod` system"
135 |   [state side prop]
136 |   (let [base (get-in @state [side prop :base] 0)\
137 |         mod (get-in @state [side prop :mod] 0)]
138 |     (+ base mod)))
139 |

--------------------------------------------------------------------------------
/src/clj/game/core/hand_size.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.hand-size
 2 |   (:require
 3 |     [game.core.effects :refer [sum-effects]]))
 4 |
 5 | (defn hand-size
 6 |   [state side]
 7 |   (or (get-in @state [side :hand-size :total]) 5))
 8 |
 9 | (defn sum-hand-size-effects
10 |   [state side]
11 |   (+ (or (get-in @state [side :hand-size :base]) 5)
12 |      (- (or (get-in @state [side :brain-damage]) 0))
13 |      (sum-effects state side :hand-size)
14 |      (sum-effects state side :user-hand-size)))
15 |
16 | (defn update-hand-size
17 |   "Update the player's hand-size"
18 |   [state side]
19 |   (let [old-total (get-in @state [side :hand-size :total])\
20 |         new-total (sum-hand-size-effects state side)\
21 |         changed? (not= old-total new-total)]
22 |     (when changed?
23 |       (swap! state assoc-in [side :hand-size :total] new-total))
24 |     changed?))
25 |
26 | (defn hand-size+
27 |   ([value] (hand-size+ (constantly true) value))
28 |   ([req value]
29 |    {:type :hand-size
30 |     :req req
31 |     :value value}))
32 |
33 | (defn corp-hand-size+
34 |   ([value] (corp-hand-size+ (constantly true) value))
35 |   ([req value]
36 |    (hand-size+ (fn [state side eid card targets]
37 |                  (and (= :corp side)
38 |                       (req state side eid card targets)))
39 |                value)))
40 |
41 | (defn runner-hand-size+
42 |   ([value] (runner-hand-size+ (constantly true) value))
43 |   ([req value]
44 |    (hand-size+ (fn [state side eid card targets]
45 |                  (and (= :runner side)
46 |                       (req state side eid card targets)))
47 |                value)))
48 |

--------------------------------------------------------------------------------
/src/clj/game/core/hosting.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.hosting
 2 |   (:require
 3 |     [game.core.card :refer [active? assoc-host-zones corp? get-card program? installed? rezzed? runner?]]
 4 |     [game.core.card-defs :refer [card-def]]
 5 |     [game.core.effects :refer [register-static-abilities unregister-static-abilities]]
 6 |     [game.core.eid :refer [make-eid]]
 7 |     [game.core.engine :refer [register-default-events unregister-events]]
 8 |     [game.core.initializing :refer [card-init]]
 9 |     [game.core.memory :refer [init-mu-cost]]
10 |     [game.core.update :refer [update! update-hosted!]]
11 |     [game.utils :refer [remove-once same-card?]]))
12 |
13 | (defn remove-from-host
14 |   "Removes a card from its host."
15 |   [state side {:keys [cid] :as card}]
16 |   (when-let [host-card (get-card state (:host card))]
17 |     (update-hosted! state side (update-in host-card [:hosted] (fn [coll] (remove-once #(= (:cid %) cid) coll))))
18 |     (when-let [hosted-lost (:hosted-lost (card-def host-card))]
19 |       (hosted-lost state side (make-eid state) (get-card state host-card) (dissoc card :host)))))
20 |
21 | (defn has-ancestor?
22 |   "Determines if the target is an ancestor of the given card (a card is its own ancestor)"
23 |   [card target]
24 |   (when (and card target) (or (same-card? card target) (has-ancestor? (:host card) target))))
25 |
26 | (defn handle-card-is-uninstalled
27 |   "If a card is hosted (uninstalled) from being installed and active, then call it's `leave-play` fn"
28 |   [state side card {:keys [installed] :as target}]
29 |   (when-let [leave-play (:leave-play (card-def target))]
30 |     (when (and (not installed)
31 |                (installed? (get-card state target))
32 |                (active? (get-card state target)))
33 |       (leave-play state (keyword (clojure.string/lower-case (:side target))) (make-eid state) target nil))))
34 |
35 | (defn host
36 |   "Host the target onto the card."
37 |   ([state side card target] (host state side card target nil))
38 |   ([state side card {:keys [zone cid host installed] :as target} {:keys [facedown no-mu]}]
39 |    (when (not= cid (:cid card))
40 |      (handle-card-is-uninstalled state side card target)
41 |      (unregister-events state side target)
42 |      (unregister-static-abilities state side target)
43 |      (doseq [s [:runner :corp]]
44 |        (if host
45 |          (when-let [host-card (get-card state host)]
46 |            (update! state side (update host-card :hosted
47 |                                        (fn [coll] (remove-once #(= (:cid %) cid) coll)))))
48 |          (swap! state update-in (cons s (vec zone))
49 |                 (fn [coll] (remove-once #(= (:cid %) cid) coll)))))
50 |      (swap! state update-in (cons side (vec zone)) (fn [coll] (remove-once #(= (:cid %) cid) coll)))
51 |      (let [card (get-card state card)\
52 |            card (assoc-host-zones card)\
53 |            target (assoc target\
54 |                          :host (dissoc card :hosted)\
55 |                          :facedown facedown\
56 |                          :zone [:onhost] ;; hosted cards should not be in :discard or :hand etc\
57 |                          :previous-zone (:zone target))\
58 |            ;; Update any cards hosted by the target, so their :host has the updated zone.\
59 |            target (update target :hosted #(map (fn [h] (assoc h :host target)) %))\
60 |            cdef (card-def card)\
61 |            tdef (card-def target)]
62 |        (update! state side (update card :hosted conj target))
63 |        (when (and installed
64 |                   (or (runner? target)
65 |                       (and (corp? target)
66 |                            (rezzed? target))))
67 |          (if (or (:recurring tdef)
68 |                  (:prevent tdef)
69 |                  (:corp-abilities tdef)
70 |                  (:runner-abilities tdef))
71 |            ;; Initialize the whole card
72 |            (card-init state side target {:resolve-effect false
73 |                                          :init-data true
74 |                                          :no-mu no-mu})
75 |            ;; Otherwise just register events and static abilities
76 |            (do (register-default-events state side target)
77 |                (register-static-abilities state side target)
78 |                (when (and (program? target)
79 |                           (not no-mu))
80 |                  (init-mu-cost state target)))))
81 |        (when-let [hosted-gained (:hosted-gained cdef)]
82 |          (hosted-gained state side (make-eid state) (get-card state card) [target]))
83 |        ;; Update all static abilities and floating effects
84 |        (let [new-effects (reduce\
85 |                            (fn [all-effects current-effect]\
86 |                              (if (= cid (:cid (:card current-effect)))\
87 |                                (conj all-effects (assoc current-effect :card target))\
88 |                                (conj all-effects current-effect)))\
89 |                            []\
90 |                            (:effects @state))]
91 |          (swap! state assoc :effects (into [] new-effects)))
92 |        (get-card state target)))))
93 |

--------------------------------------------------------------------------------
/src/clj/game/core/identities.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.identities
 2 |   (:require
 3 |     [game.core.card :refer [active?]]
 4 |     [game.core.card-defs :refer [card-def]]
 5 |     [game.core.effects :refer [register-static-abilities unregister-static-abilities]]
 6 |     [game.core.eid :refer [make-eid]]
 7 |     [game.core.engine :refer [register-default-events resolve-ability unregister-events]]
 8 |     [game.core.initializing :refer [card-init deactivate]]
 9 |     [game.core.update :refer [update!]]))
10 |
11 | (defn- actual-disable-identity
12 |   "Actually disables the side's identity"
13 |   [state side]
14 |   (let [id (update! state side (assoc (get-in @state [side :identity]) :disabled true))]
15 |     (unregister-events state side id)
16 |     (unregister-static-abilities state side id)
17 |     (when-let [leave-play (:leave-play (card-def id))]
18 |       (leave-play state side (make-eid state) id nil))))
19 |
20 | (defn disable-identity
21 |   "Disables the side's identity"
22 |   [state side]
23 |   (let [disable-count (get-in @state [side :identity :num-disables])\
24 |         id (update! state side\
25 |                     (assoc (get-in @state [side :identity])\
26 |                            :num-disables ((fnil inc 0) disable-count)))]
27 |     (when (= 1 (:num-disables id))
28 |       (actual-disable-identity state side))))
29 |
30 | (defn disable-card
31 |   "Disables a card"
32 |   [state side card]
33 |   (deactivate state side card)
34 |   (let [c (update! state side (assoc card :disabled true))]
35 |     (when-let [disable-effect (:disable (card-def c))]
36 |       (resolve-ability state side disable-effect c nil))))
37 |
38 | (defn- actual-enable-identity
39 |   "Actually enables the side's identity"
40 |   [state side]
41 |   (let [id (update! state side (assoc (get-in @state [side :identity]) :disabled false))\
42 |         {:keys [effect]} (card-def id)]
43 |     (when effect
44 |       (effect state side (make-eid state) id nil))
45 |     (register-default-events state side id)
46 |     (register-static-abilities state side id)))
47 |
48 | (defn enable-identity
49 |   "Enables the side's identity"
50 |   [state side]
51 |   (let [disable-count (get-in @state [side :identity :num-disables])\
52 |         id (update! state side\
53 |                     (assoc (get-in @state [side :identity])\
54 |                            :num-disables ((fnil dec 1) disable-count)))]
55 |     (when (= 0 (:num-disables id))
56 |       (actual-enable-identity state side))))
57 |
58 | (defn enable-card
59 |   "Enables a disabled card"
60 |   [state side {:keys [disabled] :as card}]
61 |   (when disabled
62 |     (let [c (update! state side (dissoc card :disabled))]
63 |       (when (active? card)
64 |         (card-init state side c {:resolve-effect false})))))
65 |

--------------------------------------------------------------------------------
/src/clj/game/core/initializing.clj:
--------------------------------------------------------------------------------
  1 | (ns game.core.initializing
  2 |   (:require
  3 |     [game.core.board :refer [all-active all-active-installed]]
  4 |     [game.core.card :refer [get-card map->Card program? runner?]]
  5 |     [game.core.card-defs :refer [card-def]]
  6 |     [game.core.cost-fns :refer [break-sub-ability-cost card-ability-cost]]
  7 |     [game.core.effects :refer [register-static-abilities unregister-static-abilities]]
  8 |     [game.core.eid :refer [effect-completed make-eid]]
  9 |     [game.core.engine :refer [is-ability? register-default-events register-events resolve-ability unregister-events]]
 10 |     [game.core.finding :refer [find-cid]]
 11 |     [game.core.gaining :refer [gain lose]]
 12 |     [game.core.ice :refer [add-sub]]
 13 |     [game.core.memory :refer [init-mu-cost]]
 14 |     [game.core.payment :refer [add-cost-label-to-ability]]
 15 |     [game.core.props :refer [add-counter]]
 16 |     [game.core.update :refer [update!]]
 17 |     [game.macros :refer [req]]
 18 |     [game.utils :refer [make-cid server-card to-keyword]]
 19 |     [jinteki.utils :refer [make-label]]))
 20 |
 21 | (defn subroutines-init
 22 |   "Initialised the subroutines associated with the card, these work as abilities"
 23 |   [card cdef]
 24 |   (let [no-subs-card (dissoc card :subroutines)]
 25 |     (->> (:subroutines cdef)
 26 |          (reduce (fn [ice sub] (add-sub ice sub (:cid ice) {:printed true})) no-subs-card)
 27 |          :subroutines
 28 |          (into []))))
 29 |
 30 | (defn ability-init
 31 |   "Gets abilities associated with the card"
 32 |   [cdef]
 33 |   (into [] (for [ab (:abilities cdef)\
 34 |                  :let [ab (assoc ab :label (make-label ab))]]
 35 |              (add-cost-label-to-ability ab))))
 36 |
 37 | (defn- dissoc-card
 38 |   "Dissoc relevant keys in card"
 39 |   [card keep-counter]
 40 |   (let [cdef (card-def card)\
 41 |         c (dissoc card\
 42 |                   :current-strength :current-advancement-requirement :current-points\
 43 |                   :runner-abilities :corp-abilities :rezzed :new\
 44 |                   :subtype-target :card-target :extra-advance-counter :special)\
 45 |         c (assoc c :subroutines (subroutines-init c cdef) :abilities (ability-init cdef))\
 46 |         c (if keep-counter c (dissoc c :counter :advance-counter))]
 47 |     (map->Card c)))
 48 |
 49 | (defn- trigger-leave-effect
 50 |   "Triggers leave effects for specified card if relevant"
 51 |   [state side {:keys [disabled installed rezzed facedown zone host] :as card}]
 52 |   (when-let [leave-effect (:leave-play (card-def card))]
 53 |     (when (and (not disabled)
 54 |                (not (and (runner? card) host (not installed) (not facedown)))
 55 |                (or (and (runner? card) installed (not facedown))
 56 |                    rezzed
 57 |                    (and host (not facedown))
 58 |                    (= (first zone) :current)
 59 |                    (= (first zone) :scored)))
 60 |       (leave-effect state side (make-eid state) card nil))))
 61 |
 62 | (defn deactivate
 63 |   "Deactivates a card, unregistering its events, removing certain attribute keys, and triggering
 64 |   some events."
 65 |   ([state side card] (deactivate state side card nil))
 66 |   ([state side {:keys [cid disabled installed rezzed] :as card} keep-counter]
 67 |    (unregister-events state side card)
 68 |    (unregister-static-abilities state side card)
 69 |    (trigger-leave-effect state side card)
 70 |    (when (and (find-cid cid (all-active-installed state side))
 71 |               (not disabled)
 72 |               (or rezzed
 73 |                   installed))
 74 |      (when-let [in-play (:in-play (card-def card))]
 75 |        (apply lose state side in-play)))
 76 |    (dissoc-card card keep-counter)))
 77 |
 78 |
 79 | ;;; Initialising a card
 80 | (defn corp-ability-init
 81 |   "Gets abilities associated with the card"
 82 |   [cdef]
 83 |   (into [] (for [ab (:corp-abilities cdef)\
 84 |                  :let [ab (assoc (select-keys ab [:cost]) :label (make-label ab))]]
 85 |              (add-cost-label-to-ability ab))))
 86 |
 87 | (defn runner-ability-init
 88 |   "Gets abilities associated with the card"
 89 |   [cdef]
 90 |   (into [] (for [ab (:runner-abilities cdef)\
 91 |                  :let [ab (assoc (select-keys ab [:cost :break-cost]) :label (make-label ab))]]
 92 |              (add-cost-label-to-ability ab (or (:break-cost ab) (:cost ab))))))
 93 |
 94 | (defn card-init
 95 |   "Initializes the abilities and events of the given card."
 96 |   ([state side card] (card-init state side card {:resolve-effect true :init-data true}))
 97 |   ([state side card args] (card-init state side (make-eid state) card args))
 98 |   ([state side eid card {:keys [resolve-effect init-data no-mu]}]
 99 |    (let [cdef (card-def card)\
100 |          recurring (:recurring cdef)\
101 |          run-abs (runner-ability-init cdef)\
102 |          corp-abs (corp-ability-init cdef)\
103 |          special (merge (:special card) (:special cdef))\
104 |          c (update! state side\
105 |                     (merge card {:runner-abilities run-abs\
106 |                                  :special special\
107 |                                  :corp-abilities corp-abs}))\
108 |          c (if init-data c (assoc-in c [:special :skipped-loading] true))\
109 |          data (merge\
110 |                 (when init-data (:counter (:data cdef)))\
111 |                 (when recurring\
112 |                   {:recurring\
113 |                    (cond\
114 |                      (fn? recurring) (recurring state side eid c nil)\
115 |                      (number? recurring) recurring\
116 |                      :else (throw (Exception. (str (:title card) " - Recurring isn't number or fn"))))}))\
117 |          _ (when recurring (update! state side (assoc-in c [:counter :recurring] 0)))\
118 |          _ (doseq [[c-type c-num] data]\
119 |              (add-counter state side (make-eid state eid) c c-type c-num {:placed true :suppress-checkpoint true}))\
120 |          c (get-card state c)]
121 |      ;; TODO - handle recurring credits as part of the start of turn phase (as in the CR), rather than applying events to each card
122 |      (when recurring
123 |        (let [recurring-fn (req (if (number? recurring) recurring (recurring state side eid card targets)))\
124 |              r (req (let [card (update! state side (assoc-in card [:counter :recurring] 0))\
125 |                           n (recurring-fn state side eid card targets)]\
126 |                       (add-counter state side eid card\
127 |                                    :recurring n\
128 |                                    {:placed true})))]
129 |          (register-events
130 |            state side c
131 |            [{:event (if (= side :corp) :corp-phase-12 :runner-phase-12)\
132 |              :req (req (not (:disabled card)))\
133 |              :async true\
134 |              :effect r}])))
135 |      (register-default-events state side c)
136 |      (register-static-abilities state side c)
137 |      ;; Facedown cards can't be initialized
138 |      (when (and (program? card)
139 |                 (not no-mu))
140 |        (init-mu-cost state c))
141 |      (if (and resolve-effect (is-ability? cdef))
142 |        (resolve-ability state side (assoc eid :source-type :ability) (dissoc cdef :cost :additional-cost) c nil)
143 |        (effect-completed state side eid))
144 |      (when-let [in-play (:in-play cdef)]
145 |        (apply gain state side in-play))
146 |      (get-card state c))))
147 |
148 | (defn update-ability-cost-str
149 |   [state side card ability-kw]
150 |   (into [] (for [ab (get card ability-kw)\
151 |                  :let [ab-cost\
152 |                        (cond\
153 |                          (:break-cost ab)\
154 |                          (assoc ab :cost (break-sub-ability-cost state side ab card))\
155 |                          :else\
156 |                          ab)]]
157 |              (add-cost-label-to-ability ab (card-ability-cost state side ab-cost card)))))
158 |
159 | (defn update-abilities-cost-str
160 |   [state side card]
161 |   (-> card
162 |       (assoc :abilities (update-ability-cost-str state side card :abilities))
163 |       (assoc :corp-abilities (update-ability-cost-str state side card :corp-abilities))
164 |       (assoc :runner-abilities (update-ability-cost-str state side card :runner-abilities))))
165 |
166 | (defn update-all-card-labels
167 |   [state]
168 |   (reduce (fn [changed? card]
169 |             (let [side (to-keyword (:side card))\
170 |                   new-card (update-abilities-cost-str state side card)]
171 |               (when (not= card new-card)
172 |                 (update! state side new-card))
173 |               (or (not= card new-card) changed?)))
174 |           false
175 |           (concat (all-active state :corp) (all-active state :runner))))
176 |
177 | (defn card-implemented
178 |   "Checks if the card is implemented. Looks for a valid return from `card-def`.
179 |   If implemented also looks for `:implementation` key which may contain special notes.
180 |   Returns either:
181 |     nil - not implemented
182 |     :full - implemented fully
183 |     msg - string with implementation notes"
184 |   [card]
185 |   (when-let [cdef (card-def card)]
186 |     ;; Card is defined - hence implemented
187 |     (if-let [impl (:implementation cdef)]
188 |       (if (:recurring cdef) (str impl ". Recurring credits usage not restricted") impl)
189 |       (if (:recurring cdef) "Recurring credits usage not restricted" :full))))
190 |
191 | (defn make-card
192 |   "Makes or remakes (with current cid) a proper card from a server card"
193 |   ([card] (make-card card (make-cid)))
194 |   ([card cid]
195 |    (let [cdef (card-def card)]
196 |      (-> card
197 |          (assoc :cid cid
198 |                 :implementation (card-implemented card)
199 |                 :subroutines (subroutines-init (assoc card :cid cid) cdef)
200 |                 :abilities (ability-init cdef)
201 |                 :x-fn (:x-fn cdef)
202 |                 :poison (:poison cdef)
203 |                 :highlight-in-discard (:highlight-in-discard cdef)
204 |                 :printed-title (:title card))
205 |          (dissoc :setname :text :_id :influence :number :influencelimit
206 |                  :image_url :factioncost :format :quantity)
207 |          (map->Card)))))
208 |
209 | (defn reset-card
210 |   "Resets a card back to its original state - retaining any data in the :persistent key"
211 |   ([state side {:keys [cid persistent previous-zone printed-title seen title zone]}]
212 |    (swap! state update :per-turn dissoc cid)
213 |    (let [s-card (server-card (or printed-title title))\
214 |          new-card (make-card s-card cid)]
215 |      (update! state side (assoc new-card
216 |                                 :persistent persistent
217 |                                 :previous-zone previous-zone
218 |                                 :seen seen
219 |                                 :zone zone)))))
220 |

--------------------------------------------------------------------------------
/src/clj/game/core/link.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.link
 2 |   (:require
 3 |     [game.core.effects :refer [sum-effects]]))
 4 |
 5 | (defn get-link
 6 |   ([state] (get-link state nil))
 7 |   ([state _]
 8 |    (or (get-in @state [:runner :link])
 9 |        (get-in @state [:runner :identity :baselink])
10 |        0)))
11 |
12 | (defn- sum-link-effects
13 |   [state id]
14 |   (+ (or (get-in @state [:runner :identity :baselink]) 0)
15 |      (sum-effects state :runner :user-link)
16 |      (sum-effects state :runner :link id)))
17 |
18 | (defn update-link
19 |   "Update the runner's link"
20 |   ([state] (update-link state nil))
21 |   ([state _]
22 |    (let [id (get-in @state [:runner :identity])\
23 |          old-link (get-link state)\
24 |          new-link (sum-link-effects state id)\
25 |          changed? (not= old-link new-link)]
26 |      (when changed?
27 |        (swap! state assoc-in [:runner :link] new-link))
28 |      changed?)))
29 |
30 | (defn link+
31 |   ([value] (link+ (constantly true) value))
32 |   ([req value]
33 |    {:type :link
34 |     :req req
35 |     :value value}))
36 |

--------------------------------------------------------------------------------
/src/clj/game/core/mark.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.mark
 2 |   (:require
 3 |    [game.core.engine :refer [trigger-event]]
 4 |    [game.core.say :refer [system-msg]]
 5 |    [game.core.servers :refer [central->name]]
 6 |    [game.core.update :refer [update!]]
 7 |    [game.macros :refer [req]]))
 8 |
 9 | (defn set-mark
10 |   [state new-mark]
11 |   (swap! state assoc :mark new-mark)
12 |   (trigger-event state :runner :mark-changed))
13 |
14 | (defn is-mark?
15 |   [state s]
16 |   (= s (:mark @state)))
17 |
18 | (defn identify-mark
19 |   [state]
20 |   (let [new-mark (rand-nth [:hq :rd :archives])]
21 |     (set-mark state new-mark)
22 |     (system-msg state :runner (str "identifies [their] mark to be " (central->name new-mark)))))
23 |
24 | (def identify-mark-ability
25 |   {:effect (req (when (nil? (:mark @state)) (identify-mark state)))})
26 |
27 | (def mark-changed-event
28 |   {:event :mark-changed
29 |    :silent (req true)
30 |    :interactive (req false)
31 |    :effect (req (update! state :runner (assoc card :card-target (central->name (:mark @state)))))})
32 |

--------------------------------------------------------------------------------
/src/clj/game/core/memory.clj:
--------------------------------------------------------------------------------
  1 | (ns game.core.memory
  2 |   (:require
  3 |    [cond-plus.core :refer [cond+]]
  4 |    [game.core.card :refer [has-subtype? virus-program? program?]]
  5 |    [game.core.card-defs :refer [card-def]]
  6 |    [game.core.eid :refer [make-eid]]
  7 |    [game.core.effects :refer [get-effect-maps get-effect-value get-effects is-disabled-reg? register-lingering-effect]]
  8 |    [game.core.toasts :refer [toast]]))
  9 |
 10 | (defn mu+
 11 |   "For use in :static-abilities and register-lingering-effect.
 12 |   Returns an effect map for :available-mu.
 13 |   Takes either the mu value or a :req 5-fn and the value.
 14 |   The mu value can just the amount of (regular) mu,
 15 |   or a vector of the mu type and amount or a function that returns that vector."
 16 |   ([value] (mu+ (constantly true) value))
 17 |   ([req value]
 18 |    {:type :available-mu
 19 |     :req req
 20 |     :value (cond+
 21 |              [(or (vector? value) (fn? value)) value]
 22 |              [(number? value) [:regular value]]
 23 |              [:else (throw (Exception. (str "mu+ needs a vector, number, or function: " value)))])}))
 24 |
 25 | (defn virus-mu+
 26 |   "Provide a wrapper to mu+ for fixed virus only mu.
 27 |   Takes either the mu amount or a :req 5-fn and the mu amount."
 28 |   ([amount] (virus-mu+ (constantly true) amount))
 29 |   ([req amount] (mu+ req [:virus amount])))
 30 |
 31 | (defn caissa-mu+
 32 |   "Provide a wrapper to mu+ for fixed caissa only mu.
 33 |   Takes either the mu amount or a :req 5-fn and the mu amount."
 34 |   ([amount] (caissa-mu+ (constantly true) amount))
 35 |   ([req amount] (mu+ req [:caissa amount])))
 36 |
 37 | (defn available-mu
 38 |   "Returns the available MU the runner has"
 39 |   ([state] (available-mu state nil))
 40 |   ([state _]
 41 |    (let [memory (get-in @state [:runner :memory])]
 42 |      (- (reduce + (or (:available memory) 0)
 43 |                 (keep :available (vals (:only-for memory))))
 44 |         (or (:used memory) 0)))))
 45 |
 46 | (defn- get-available-mu
 47 |   "Returns a list of vec pairs: [mu-type value]"
 48 |   [state]
 49 |   (concat [[:regular (or (get-in @state [:runner :memory :base]) 0)]]
 50 |           (get-effects state :runner :user-available-mu)
 51 |           (get-effects state :runner :available-mu)))
 52 |
 53 | (def type-preds
 54 |   {:caissa #(has-subtype? % "Caïssa")
 55 |    :virus virus-program?})
 56 |
 57 | (defn- merge-available-memory
 58 |   [mu-list]
 59 |   (reduce
 60 |     (fn [acc [mu-type amount]]
 61 |       (update acc mu-type (fnil + 0) amount))
 62 |     (zipmap (conj (keys type-preds) :regular) (repeat 0))
 63 |     mu-list))
 64 |
 65 | (defn- merge-used-memory
 66 |   "Convert the list of used-mu-effects to a map saying how much each type is used:
 67 |   1. Create a zero'd map of the mu-type keywords
 68 |   2. For each of the used mu effects, check which of the mu types it might use
 69 |   3. Increment relevant mu type"
 70 |   [state used-mu-effects]
 71 |   (let [effect-value-fn (get-effect-value state :runner)\
 72 |         initial-used-mu (zipmap (conj (keys type-preds) :regular) (repeat 0))]
 73 |     (reduce
 74 |       (fn [acc effect]
 75 |         (loop [type-preds type-preds]
 76 |           (let [[mu-type pred] (first type-preds)]
 77 |             (cond+
 78 |               ;; If we've looped through and mu-type is now `nil`, increment regular
 79 |               [(nil? mu-type)\
 80 |                (update acc :regular (fnil + 0 0) (effect-value-fn effect))]
 81 |               ;; Otherwise, check the pred against the card
 82 |               [(pred (:card effect))\
 83 |                (update acc mu-type (fnil + 0 0) (effect-value-fn effect))]
 84 |               ;; Loop it up
 85 |               [:else\
 86 |                (recur (next type-preds))]))))
 87 |       initial-used-mu
 88 |       used-mu-effects)))
 89 |
 90 | (defn combine-used-mu
 91 |   [available-mu used-mu]
 92 |   (reduce
 93 |     (fn [total-used mu-type]
 94 |       (let [available (or (get available-mu mu-type) 0)\
 95 |             used (or (get used-mu mu-type) 0)\
 96 |             diff (- available used)]
 97 |         (+ total-used
 98 |            ;; the specific memory "overflowed" and we want to add
 99 |            ;; the overflow to the total used
100 |            (if (neg? diff)
101 |              (- diff)
102 |              0))))
103 |     (or (:regular used-mu) 0)
104 |     (keys type-preds)))
105 |
106 | (defn build-new-mu
107 |   [state]
108 |   (let [mu-list (get-available-mu state)\
109 |         available-mu (merge-available-memory mu-list)\
110 |         used-mu-effects (get-effect-maps state :runner :used-mu)\
111 |         used-mu (merge-used-memory state used-mu-effects)\
112 |         only-for (into {} (for [mu-type (keys type-preds)]\
113 |                             [mu-type {:available (get available-mu mu-type)\
114 |                                       :used (get used-mu mu-type)}]))\
115 |         total-available (:regular available-mu)\
116 |         total-used (combine-used-mu available-mu used-mu)]
117 |     {:only-for only-for
118 |      :available total-available
119 |      :used total-used}))
120 |
121 | (defn update-mu
122 |   ([state] (update-mu state nil))
123 |   ([state _]
124 |    (let [old-mu (select-keys (get-in @state [:runner :memory]) [:available :used :only-for])\
125 |          new-mu (build-new-mu state)\
126 |          changed? (not= old-mu new-mu)]
127 |      (when changed?
128 |        (when (neg? (- (:available new-mu) (:used new-mu)))
129 |          (toast state :runner "You have exceeded your memory units!"))
130 |        (swap! state update-in [:runner :memory] merge new-mu))
131 |      changed?)))
132 |
133 | (defn some-mu-effect?
134 |   [state card]
135 |   (let [ab (first (filter #(= (:type %) :used-mu) (:static-abilities (card-def card))))\
136 |         abreq (:req ab)\
137 |         abval (:value ab)]
138 |     (if (and ab (or (nil? abreq) (abreq state :runner nil card nil)))
139 |       (abval state :runner nil card nil)
140 |       0)))
141 |
142 | (defn expected-mu
143 |   [state card]
144 |   (if (program? card)
145 |     (+ (:memoryunits card) (some-mu-effect? state card))
146 |     0))
147 |
148 | (defn sufficient-mu?
149 |   "Will installing this card put the runner over their memory limit?"
150 |   [state card]
151 |   (when (program? card)
152 |     (let [mu-cost (expected-mu state card)\
153 |           mu-list (get-available-mu state)\
154 |           available-mu (merge-available-memory mu-list)\
155 |           used-mu-effects (conj (get-effect-maps state :runner :used-mu)\
156 |                                 {:type :used-mu\
157 |                                  :duration :while-active\
158 |                                  :card card\
159 |                                  :value mu-cost})\
160 |           used-mu (merge-used-memory state used-mu-effects)\
161 |           total-available (:regular available-mu)\
162 |           total-used (combine-used-mu available-mu used-mu)]
163 |       (<= 0 (- total-available total-used)))))
164 |
165 | (defn init-mu-cost
166 |   "(re) establish lingering effect of program using up memory"
167 |   [state card]
168 |   (register-lingering-effect
169 |     state :runner card
170 |     {:type :used-mu
171 |      :duration :while-active
172 |      :value (:memoryunits card)})
173 |   (update-mu state))
174 |

--------------------------------------------------------------------------------
/src/clj/game/core/optional.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.optional
 2 |   (:require
 3 |     [game.core.card :refer [get-card]]
 4 |     [game.core.eid :refer [effect-completed make-eid]]
 5 |     [game.core.engine :refer [can-trigger? register-ability-type register-once resolve-ability]]
 6 |     [game.core.payment :refer [can-pay?]]
 7 |     [game.core.prompts :refer [show-prompt]]
 8 |     [game.core.toasts :refer [toast]]
 9 |     [game.core.update :refer [update!]]
10 |     [game.macros :refer [effect req wait-for]]
11 |     [clojure.string :as string]))
12 |
13 | (defn optional-ability
14 |   "Shows a 'Yes/No' prompt and resolves the given ability's :yes-ability if Yes is chosen, and :no-ability otherwise.
15 |   If ability has an :autoresolve entry, first call it as a 5-function, and if it returns 'Yes' or 'No'
16 |   resolve the ability as if prompt was displayed and Yes/No was chosen."
17 |   ([state side eid card message ability targets]
18 |    (letfn [(prompt-fn [prompt-choice]\
19 |              (let [yes-ability (:yes-ability ability)\
20 |                    no-ability (:no-ability ability)\
21 |                    end-effect (:end-effect ability)\
22 |                    new-eid (make-eid state eid)\
23 |                    ability-to-do (if (and (= (:value prompt-choice) "Yes")\
24 |                                           yes-ability\
25 |                                           (can-pay? state side eid card (:title card) (:cost yes-ability)))\
26 |                                    (assoc yes-ability :once (:once ability))\
27 |                                    no-ability)]\
28 |                (wait-for (resolve-ability state side new-eid ability-to-do card targets)\
29 |                          (when end-effect\
30 |                            (end-effect state side new-eid card targets))\
31 |                          (effect-completed state side eid))))]
32 |      (let [autoresolve-fn (:autoresolve ability)\
33 |            autoresolve-answer (when autoresolve-fn\
34 |                                 (autoresolve-fn state side eid card targets))\
35 |            choices [(when (can-pay? state side eid card (:title card) (:cost (:yes-ability ability)))\
36 |                       "Yes")\
37 |                     "No"]]
38 |        (case autoresolve-answer
39 |          "Yes" (prompt-fn {:value "Yes"})
40 |          "No" (prompt-fn {:value "No"})
41 |          (do (when autoresolve-fn
42 |                (toast state side (str "This prompt can be skipped by clicking "
43 |                                       (:title card) " and toggling autoresolve")))
44 |              (show-prompt state side eid card message choices
45 |                           prompt-fn (assoc ability :targets targets))))))))
46 |
47 | (defn- check-optional
48 |   "Checks if there is an optional ability to resolve"
49 |   [state side {:keys [eid optional] :as ability} card targets]
50 |   (assert (not (contains? optional :async)) "Put :async in the :yes-ability")
51 |   (if (can-trigger? state side eid optional card targets)
52 |     (resolve-ability
53 |       state side
54 |       (-> ability
55 |           (dissoc :optional :once :req)
56 |           (assoc :async true
57 |                  :effect (req (optional-ability state (or (:player optional) side) eid card (:prompt optional) optional targets))))
58 |       card targets)
59 |     (effect-completed state side eid)))
60 |
61 | (register-ability-type :optional #'check-optional)
62 |
63 | (defn never?
64 |   "Returns true if is argument is :never."
65 |   [x]
66 |   (= :never x))
67 |
68 | (defn set-autoresolve
69 |   "Makes a card ability which lets the user toggle auto-resolve on an ability. Setting is stored under [:special toggle-kw]."
70 |   [toggle-kw ability-name]
71 |   {:autoresolve true
72 |    :label (str "Toggle auto-resolve on " ability-name)
73 |    :prompt (str "Set auto-resolve on " ability-name " to:")
74 |    :choices ["Always" "Never" "Ask"]
75 |    :effect (effect (update! (assoc-in card [:special toggle-kw] (keyword (string/lower-case target))))
76 |                    (toast (str "From now on, " ability-name " will "
77 |                                ({:always "always" :never "never" :ask "ask whether it should"}
78 |                                 (get-in (get-card state card) [:special toggle-kw]))
79 |                                " resolve.") "info"))})
80 |
81 | (defn get-autoresolve
82 |   "Returns a 5-fn intended for use in the :autoresolve of an optional ability. Function returns 'Yes', 'No' or nil
83 |   depending on whether card has [:special toggle-kw] set to :always, :never or something else.
84 |   If a function is passed in, instead call that on [:special toggle-kw] and return the result."
85 |   ([toggle-kw] (get-autoresolve toggle-kw {:always "Yes" :never "No"}))
86 |   ([toggle-kw pred] (req (pred (get-in (get-card state card) [:special toggle-kw])))))
87 |

--------------------------------------------------------------------------------
/src/clj/game/core/payment.clj:
--------------------------------------------------------------------------------
  1 | (ns game.core.payment
  2 |   (:require
  3 |     [clojure.string :as string]
  4 |     [game.core.board :refer [all-active-installed]]
  5 |     [game.core.card :refer [ice?]]
  6 |     [game.core.eid :refer [make-eid]]
  7 |     [game.core.effects :refer [any-effects]]
  8 |     [game.core.toasts :refer [toast]]
  9 |     [jinteki.utils :refer [capitalize]]))
 10 |
 11 | (defn ->c
 12 |   ([type] (->c type 1))
 13 |   ([type n] (->c type n nil))
 14 |   ([type n {:keys [additional stealth maximum] :as args}]
 15 |    {:cost/type type
 16 |     :cost/amount n
 17 |     :cost/additional (boolean additional)
 18 |     :cost/stealth stealth
 19 |     :cost/maximum maximum
 20 |     :cost/args (not-empty (dissoc args :stealth :additional))}))
 21 |
 22 | (defmulti value :cost/type)
 23 | (defmethod value :default [_] 0)
 24 | (defmulti stealth-value :cost/type)
 25 | (defmethod stealth-value :default [_] 0)
 26 | (defmulti label :cost/type)
 27 | (defn- payable-dispatch [cost _state _side _eid _card] (:cost/type cost))
 28 | (defmulti payable? #'payable-dispatch)
 29 | (defn- handler-dispatch [cost _state _side _eid _card] (:cost/type cost))
 30 | (defmulti handler #'handler-dispatch)
 31 |
 32 | (defn group-costs
 33 |   [costs]
 34 |   (->> costs
 35 |        (group-by #(let [cost-name (:cost/type %)]
 36 |                     ;; Don't group :x-credits
 37 |                     (if (= :x-credits cost-name)
 38 |                       (gensym)
 39 |                       cost-name)))
 40 |        (vals)))
 41 |
 42 | (defn merge-cost-impl
 43 |   "Reducing function for merging costs of the same type, respecting stealth requirements."
 44 |   [acc cur]
 45 |   (let [acc-stealth (:cost/stealth acc)\
 46 |         cur-stealth (:cost/stealth cur)]
 47 |     (->c (:cost/type cur)
 48 |          (+ (:cost/amount acc 0) (:cost/amount cur 0))
 49 |          (conj {:additional (:cost/additional cur)
 50 |                 :stealth (cond
 51 |                            (or (= :all-stealth acc-stealth)
 52 |                                (= :all-stealth cur-stealth))
 53 |                            :all-stealth
 54 |                            (or acc-stealth cur-stealth)
 55 |                            (+ (or acc-stealth 0) (or cur-stealth 0)))}
 56 |                (:cost/args acc)
 57 |                (:cost/args cur)))))
 58 |
 59 | (defn- display-cost-ranks
 60 |   [cost]
 61 |   (case (:cost/type cost)
 62 |     :click 1
 63 |     :lose-click 2
 64 |     :credit 3
 65 |     (:trash-can :remove-from-game) 4
 66 |     ; :else
 67 |     5))
 68 |
 69 | (defn- impl-cost-ranks
 70 |   [cost]
 71 |   (case (:cost/type cost)
 72 |     :click 1
 73 |     :lose-click 2
 74 |     :credit 3
 75 |     (:advancement :power :virus) 4
 76 |     (:trash-can :remove-from-game) 5
 77 |     ; :else
 78 |     6))
 79 |
 80 | (defn merge-costs
 81 |   "Combines disparate costs into a single cost per type."
 82 |   ([costs] (merge-costs costs false))
 83 |   ([costs remove-zero-credit-cost]
 84 |    (let [costs (filterv some? (flatten [costs]))\
 85 |          {real false additional true} (group-by :cost/additional costs)\
 86 |          real (group-costs real)\
 87 |          additional (group-costs additional)]
 88 |      (->> (concat real additional)
 89 |           (keep #(reduce merge-cost-impl nil %))
 90 |           (remove #(if remove-zero-credit-cost
 91 |                      (and (= :credit (:cost/type %))
 92 |                           (zero? (:cost/amount %)))
 93 |                      false))
 94 |           (sort-by impl-cost-ranks)
 95 |           (into [])))))
 96 |
 97 | (comment
 98 |   (= [(->c :click 4) (->c :credit 2)] (merge-costs [[(->c :click 1)] [(->c :click 3)] [(->c :credit 1)] [(->c :credit 1)]]))
 99 |   (= [(->c :click 4) (->c :credit 2)] (merge-costs [[(->c :credit 1)] [(->c :credit 1)] [(->c :click 1)] [(->c :click 3)]])))
100 |
101 | (defn- any-effect-stops-pay?
102 |   "Checks installed cards to see if payment type is being prevented by an active card"
103 |   [state side cost]
104 |   (let [kw-cost (keyword (str "cannot-pay-" (name (:cost/type cost))))]
105 |     (any-effects state side kw-cost true? {:amount (:cost/amount cost)})))
106 |
107 | (defn can-pay?
108 |   "Returns nil if the player cannot pay the cost args, or a truthy map otherwise.
109 |   If title is specified a toast will be generated if the player is unable to pay
110 |   explaining which cost they were unable to pay."
111 |   ([state side title args] (can-pay? state side (make-eid state) nil title args))
112 |   ([state side eid card title & args]
113 |    (let [remove-zero-credit-cost (and (= (:source-type eid) :corp-install)\
114 |                                       (not (ice? card)))\
115 |          costs (merge-costs (filter some? args) remove-zero-credit-cost)]
116 |      (if (every? #(and (not (any-effect-stops-pay? state side %))
117 |                        (payable? % state side eid card))
118 |                  costs)
119 |        costs
120 |        (do (when title (toast state side (str "Unable to pay for " title ".")))
121 |            nil)))))
122 |
123 | (defn cost-targets
124 |   [eid cost-type]
125 |   (get-in eid [:cost-paid cost-type :paid/targets]))
126 |
127 | (defn cost-target
128 |   [eid cost-type]
129 |   (first (cost-targets eid cost-type)))
130 |
131 | (defn cost-value
132 |   [eid cost-type]
133 |   (get-in eid [:cost-paid cost-type :paid/value]))
134 |
135 | ;; the function `pay` is defined in resolve-ability because they're all intermingled
136 | ;; fuck the restriction against circular dependencies, for real
137 |
138 | ;; cost labels and messages
139 | (defn build-cost-label
140 |   "Gets the complete cost-label for specified costs"
141 |   [costs]
142 |   (let [cost-string\
143 |         (->> (merge-costs costs)\
144 |              (sort-by display-cost-ranks)\
145 |              (map label)\
146 |              (interpose ", ")\
147 |              (apply str))]
148 |     (when (not (string/blank? cost-string))
149 |       (capitalize cost-string))))
150 |
151 | (defn add-cost-label-to-ability
152 |   ([ability] (add-cost-label-to-ability ability (:cost ability)))
153 |   ([ability cost]
154 |    (assoc ability :cost-label
155 |           (build-cost-label (if (:trash-icon ability)
156 |                               (conj cost [(->c :trash-can)])
157 |                               cost)))))
158 |
159 | (comment
160 |   (= "[Click][Click][Click][Click], 1 [Credits], suffer 1 net damage"
161 |      (build-cost-label [(->c :click 1) (->c :click 3) (->c :net 1) (->c :credit 1)])))
162 |
163 | (defn cost->string
164 |   "Converts a cost to a string for printing"
165 |   [cost]
166 |   (if (:cost/type cost)
167 |     (when (not (neg? (value cost)))
168 |       (let [cost-type (:cost/type cost)\
169 |             cost-string (label cost)]
170 |         (cond
171 |           (#{:click :lose-click} cost-type) (str "spend " cost-string)
172 |           (= :credit cost-type) (str "pay " cost-string)
173 |           :else cost-string)))
174 |     (try (cost->string (first cost))
175 |          (catch Throwable t
176 |            (prn cost)
177 |            (throw t)))))
178 |
179 | (defn build-cost-string
180 |   "Gets the complete cost-str for specified costs"
181 |   [costs]
182 |   (let [cost-string\
183 |         (->> (merge-costs costs)\
184 |              (filter some?)\
185 |              (map cost->string)\
186 |              (interpose " and ")\
187 |              (apply str))]
188 |     (when (not (string/blank? cost-string))
189 |       (capitalize cost-string))))
190 |
191 | (defn build-spend-msg
192 |   "Constructs the spend message for specified cost-str and verb(s)."
193 |   ([cost-str verb] (build-spend-msg cost-str verb nil))
194 |   ([cost-str verb verb2]
195 |    (if (string/blank? cost-str)
196 |      (str (or verb2 (str verb "s")) " ")
197 |      (str cost-str " to " verb " "))))
198 |

--------------------------------------------------------------------------------
/src/clj/game/core/player.clj:
--------------------------------------------------------------------------------
  1 | (ns game.core.player)
  2 |
  3 | (defrecord HandSize
  4 |   [base total])
  5 |
  6 | (defrecord Corp
  7 |   [aid\
  8 |    user\
  9 |    identity\
 10 |    options\
 11 |    basic-action-card\
 12 |    deck\
 13 |    deck-id\
 14 |    hand\
 15 |    discard\
 16 |    scored\
 17 |    rfg\
 18 |    play-area\
 19 |    current\
 20 |    set-aside\
 21 |    set-aside-tracking\
 22 |    servers\
 23 |    trash-like-cards\
 24 |    click\
 25 |    click-per-turn\
 26 |    credit\
 27 |    bad-publicity\
 28 |    toast\
 29 |    hand-size\
 30 |    agenda-point\
 31 |    agenda-point-req\
 32 |    keep\
 33 |    quote])
 34 |
 35 | (defrecord Servers
 36 |   [hq rd archives])
 37 |
 38 | (defrecord BadPublicity
 39 |   [base additional])
 40 |
 41 | (defn new-corp
 42 |   [user c-identity options deck deck-id c-quote]
 43 |   (map->Corp
 44 |     {:aid 0
 45 |      :user user
 46 |      :identity c-identity
 47 |      :options options
 48 |      :basic-action-card nil
 49 |      :deck deck
 50 |      :deck-id deck-id
 51 |      :hand []
 52 |      :discard [] :scored [] :rfg [] :play-area [] :current [] :set-aside [] :set-aside-tracking {}
 53 |      :servers (map->Servers {:hq {:content [] :ices []}
 54 |                              :rd {:content [] :ices []}
 55 |                              :archives {:content [] :ices []}})
 56 |      :click 0 :click-per-turn 3
 57 |      :credit 5
 58 |      :bad-publicity (map->BadPublicity {:base 0 :additional 0})
 59 |      :toast []
 60 |      :trash-like-cards nil
 61 |      :hand-size (map->HandSize {:base 5 :total 5})
 62 |      :agenda-point 0 :agenda-point-req 7
 63 |      :keep false
 64 |      :quote c-quote}))
 65 |
 66 | (defrecord Runner
 67 |   [aid\
 68 |    user\
 69 |    identity\
 70 |    options\
 71 |    basic-action-card\
 72 |    deck\
 73 |    deck-id\
 74 |    hand\
 75 |    discard\
 76 |    scored\
 77 |    rfg\
 78 |    play-area\
 79 |    current\
 80 |    set-aside\
 81 |    set-aside-tracking\
 82 |    rig\
 83 |    toast\
 84 |    click\
 85 |    click-per-turn\
 86 |    credit\
 87 |    run-credit\
 88 |    link\
 89 |    tag\
 90 |    trash-like-cards\
 91 |    memory\
 92 |    hand-size\
 93 |    agenda-point\
 94 |    agenda-point-req\
 95 |    hq-access\
 96 |    rd-access\
 97 |    rd-access-fn\
 98 |    brain-damage\
 99 |    keep\
100 |    quote])
101 |
102 | (defrecord Rig
103 |   [facedown hardware program resource])
104 |
105 | (defrecord Tags
106 |   [base total is-tagged])
107 |
108 | (defn new-runner
109 |   [user r-identity options deck deck-id r-quote]
110 |   (map->Runner
111 |     {:aid 0
112 |      :user user
113 |      :identity r-identity
114 |      :options options
115 |      :basic-action-card nil
116 |      :deck deck
117 |      :deck-id deck-id
118 |      :hand []
119 |      :discard [] :scored [] :rfg [] :play-area [] :current [] :set-aside [] :set-aside-tracking {}
120 |      :rig (map->Rig {:facedown [] :hardware [] :program [] :resource []})
121 |      :toast []
122 |      :click 0 :click-per-turn 4
123 |      :credit 5 :run-credit 0
124 |      :trash-like-cards nil
125 |      :link 0
126 |      :tag (map->Tags {:base 0 :total 0 :is-tagged false})
127 |      :memory {:base 4
128 |               :available 0
129 |               :used 0
130 |               :only-for {}}
131 |      :hand-size (map->HandSize {:base 5 :total 5})
132 |      :agenda-point 0 :agenda-point-req 7
133 |      :rd-access-fn seq
134 |      :hq-access-fn shuffle
135 |      :brain-damage 0
136 |      :keep false
137 |      :quote r-quote}))
138 |

--------------------------------------------------------------------------------
/src/clj/game/core/process_actions.clj:
--------------------------------------------------------------------------------
  1 | (ns game.core.process-actions
  2 |   (:require
  3 |    [clojure.string :as str]
  4 |    [game.core.actions :refer [click-advance click-credit click-draw click-run\
  5 |                               close-deck do-purge generate-install-list\
  6 |                               generate-runnable-zones move-card expend-ability\
  7 |                               play play-ability play-corp-ability\
  8 |                               play-dynamic-ability play-runner-ability play-subroutine play-unbroken-subroutines remove-tag\
  9 |                               resolve-prompt score select trash-resource view-deck]]
 10 |    [game.core.card :refer [get-card]]
 11 |    [game.core.change-vals :refer [change]]
 12 |    [game.core.checkpoint :refer [fake-checkpoint]]
 13 |    [game.core.commands :refer [parse-command]]
 14 |    [game.core.eid :refer [make-eid]]
 15 |    [game.core.moving :refer [trash]]
 16 |    [game.core.rezzing :refer [derez rez]]
 17 |    [game.core.runs :refer [check-for-empty-server continue handle-end-run\
 18 |                            jack-out start-next-phase toggle-auto-no-action]]
 19 |    [game.core.say :refer [indicate-action say system-msg system-say]]
 20 |    [game.core.set-up :refer [keep-hand mulligan]]
 21 |    [game.core.shuffling :refer [shuffle-deck]]
 22 |    [game.core.toasts :refer [ack-toast]]
 23 |    [game.core.turns :refer [end-phase-12 end-turn start-turn]]
 24 |    [game.core.winning :refer [concede]]))
 25 |
 26 | (defn checkpoint+clean-up
 27 |   [state]
 28 |   (fake-checkpoint state)
 29 |   ;; End the run if running an empty remote
 30 |   (when (or (check-for-empty-server state)
 31 |             (:ended (:end-run @state)))
 32 |     (handle-end-run state :corp nil)
 33 |     (fake-checkpoint state)))
 34 |
 35 | (defn set-property
 36 |   "set properties of the game state that need to be adjustable by the frontend
 37 |   ie: * do we want an offer to trash like cards on installs?"
 38 |   [state side {:keys [key value]}]
 39 |   (case key
 40 |     :trash-like-cards (swap! state assoc-in [side :trash-like-cards] value)))
 41 |
 42 | (defn command-parser
 43 |   [state side {:keys [user text] :as args}]
 44 |   (let [author (or user (get-in @state [side :user]))\
 45 |         text (if (= (str/trim text) "null") " null" text)]
 46 |     (if-let [command (parse-command state text)]
 47 |       (when (and (not= side nil) (not= side :spectator))
 48 |         (command state side)
 49 |         (system-say state side (str "[!]" (:username author) " uses a command: " text)))
 50 |       (say state side args))))
 51 |
 52 | (def commands
 53 |   {"ability" #'play-ability
 54 |    "advance" #'click-advance
 55 |    "change" #'change
 56 |    "choice" #'resolve-prompt
 57 |    "close-deck" #'close-deck
 58 |    "concede" #'concede
 59 |    "continue" #'continue
 60 |    "corp-ability" #'play-corp-ability
 61 |    "credit" #'click-credit
 62 |    "derez" #(derez %1 %2 (:card %3))
 63 |    "draw" #'click-draw
 64 |    "dynamic-ability" #'play-dynamic-ability
 65 |    "end-phase-12" #'end-phase-12
 66 |    "start-next-phase" #'start-next-phase
 67 |    "end-turn" #'end-turn
 68 |    "generate-install-list" #'generate-install-list
 69 |    "generate-runnable-zones" #'generate-runnable-zones
 70 |    "indicate-action" #'indicate-action
 71 |    "jack-out" #'jack-out
 72 |    "keep" #'keep-hand
 73 |    "move" #'move-card
 74 |    "mulligan" #'mulligan
 75 |    "play" #'play
 76 |    "expend" #'expend-ability
 77 |    "purge" #'do-purge
 78 |    "remove-tag" #'remove-tag
 79 |    "rez" #(rez %1 %2 (make-eid %1) (:card %3) (dissoc %3 :card))
 80 |    "run" #'click-run
 81 |    "runner-ability" #'play-runner-ability
 82 |    "score" #(score %1 %2 (make-eid %1) (get-card %1 (:card %3)) nil)
 83 |    "select" #'select
 84 |    "set-property" #'set-property
 85 |    "shuffle" #'shuffle-deck
 86 |    "start-turn" #'start-turn
 87 |    "subroutine" #'play-subroutine
 88 |    "system-msg" #(system-msg %1 %2 (:msg %3))
 89 |    "toast" #'ack-toast
 90 |    "toggle-auto-no-action" #'toggle-auto-no-action
 91 |    "trash" #(trash %1 %2 (make-eid %1) (get-card %1 (:card %3)) (dissoc %3 :card))
 92 |    "trash-resource" #'trash-resource
 93 |    "unbroken-subroutines" #'play-unbroken-subroutines
 94 |    "view-deck" #'view-deck})
 95 |
 96 | (defn process-action
 97 |   [command state side args]
 98 |   (when-let [c (get commands command)]
 99 |     (c state side args)
100 |     (checkpoint+clean-up state)
101 |     true))
102 |

--------------------------------------------------------------------------------
/src/clj/game/core/prompt_state.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.prompt-state)
 2 |
 3 | (defn set-prompt-state
 4 |   ([state side]
 5 |    (let [current-prompt (first (get-in @state [side :prompt]))]
 6 |      (set-prompt-state state side current-prompt)))
 7 |   ([state side prompt]
 8 |    (swap! state assoc-in [side :prompt-state] prompt)))
 9 |
10 | (defn remove-from-prompt-queue
11 |   [state side prompt]
12 |   (swap! state update-in [side :prompt] (fn [pr] (remove #(= % prompt) pr)))
13 |   (set-prompt-state state side))
14 |
15 | (defn add-to-prompt-queue
16 |   "Adds a newly created prompt to the current prompt queue"
17 |   [state side prompt]
18 |   (swap! state update-in [side :prompt] #(cons prompt %))
19 |   (set-prompt-state state side))
20 |

--------------------------------------------------------------------------------
/src/clj/game/core/props.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.props
 2 |   (:require
 3 |     [game.core.card :refer [get-card ice? rezzed?]]
 4 |     [game.core.eid :refer [effect-completed make-eid]]
 5 |     [game.core.engine :refer [checkpoint queue-event trigger-event-sync]]
 6 |     [game.core.finding :refer [find-latest]]
 7 |     [game.core.gaining :refer [gain-credits]]
 8 |     [game.core.ice :refer [update-ice-strength]]
 9 |     [game.core.update :refer [update!]]))
10 |
11 | (defn add-prop
12 |   "Adds the given value n to the existing value associated with the key in the card.
13 |   Example: (add-prop ... card :counter 1) adds one power/virus counter. Triggers events."
14 |   ([state side eid card prop-type n] (add-prop state side eid card prop-type n nil))
15 |   ([state side eid card prop-type n {:keys [placed suppress-checkpoint]}]
16 |    (if-let [card (get-card state card)]
17 |      (let [updated-card (update! state side (update card prop-type #(+ (or % 0) n)))\
18 |            args {:counter-type prop-type :amount n :placed placed}]
19 |        (if (= prop-type :advance-counter)
20 |          (do (when (and (ice? updated-card)
21 |                         (rezzed? updated-card))
22 |                (update-ice-strength state side updated-card))
23 |              (queue-event state (if placed :advancement-placed :advance) (assoc args :card (get-card state updated-card))))
24 |          (queue-event state :counter-added (assoc args :card (get-card state updated-card))))
25 |        (if-not suppress-checkpoint
26 |          (checkpoint state side eid)
27 |          (effect-completed state side eid)))
28 |      (effect-completed state side eid))))
29 |
30 | (defn add-counter
31 |   "Adds n counters of the specified type to a card"
32 |   ([state side eid card prop-type n] (add-counter state side eid card prop-type n nil))
33 |   ([state side eid card prop-type n {:keys [placed suppress-checkpoint] :as args}]
34 |    ;;(println "N: " n ", card: " (:title card), ", side: " side ", prop-type: " prop-type ", args: " args)
35 |    (if-let [card (get-card state card)]
36 |      (if (= prop-type :advancement)
37 |        ;; if advancement counter use existing system
38 |        (add-prop state side eid card :advance-counter n args)
39 |        (let [updated-card (update! state side (update-in card [:counter prop-type] #(+ (or % 0) n)))]
40 |          (queue-event state :counter-added {:card updated-card :counter-type prop-type :amount n :placed placed})
41 |          (if-not suppress-checkpoint
42 |            (checkpoint state side eid)
43 |            (effect-completed state side eid))))
44 |      (effect-completed state side eid))))
45 |
46 | (defn set-prop
47 |   "Like add-prop, but sets multiple keys to corresponding values without triggering events.
48 |   Example: (set-prop ... card :counter 4 :current-strength 0)"
49 |   [state side card & args]
50 |   (update! state side (apply assoc (cons card args))))
51 |
52 | (defn add-icon
53 |   "Adds an icon to a card. E.g. a Femme Fatale token.
54 |   Card is the card adding the icon, target is card receiving the icon."
55 |   [state side card target char color]
56 |   ;; add icon
57 |   (set-prop state side target :icon {:char char :color color :card card})
58 |   ;; specify icon target on card
59 |   (set-prop state side card :icon-target target))
60 |
61 | (defn remove-icon
62 |   "Remove the icon associated with the card and target."
63 |   ([state side card] (remove-icon state side card (:icon-target card)))
64 |   ([state side card target]
65 |    (when target (set-prop state side (find-latest state target) :icon nil))
66 |    (set-prop state side (find-latest state card) :icon-target nil)))
67 |

--------------------------------------------------------------------------------
/src/clj/game/core/psi.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.psi
 2 |   (:require
 3 |     [game.core.card :refer [corp?]]
 4 |     [game.core.costs :refer [total-available-credits]]
 5 |     [game.core.eid :refer [effect-completed make-eid]]
 6 |     [game.core.engine :refer [can-trigger? pay register-ability-type register-once resolve-ability trigger-event-simult]]
 7 |     [game.core.flags :refer [any-flag-fn?]]
 8 |     [game.core.prompts :refer [clear-wait-prompt show-prompt-with-dice show-wait-prompt]]
 9 |     [game.core.say :refer [system-msg]]
10 |     [game.macros :refer [continue-ability effect wait-for]]
11 |     [jinteki.utils :refer [str->int]]
12 |     [clojure.string :as string]
13 |     [game.core.payment :refer [->c]]))
14 |
15 | (defn- bet-to-keyword
16 |   [bet]
17 |   (keyword (str "bet-" bet)))
18 |
19 | (defn- resolve-psi
20 |   "Resolves a psi game by charging credits to both sides and invoking the appropriate
21 |   resolution ability."
22 |   [state side eid card psi bet targets]
23 |   (swap! state update-in [:stats side :psi-game (bet-to-keyword bet)] (fnil + 0) 1)
24 |   (swap! state update-in [:stats side :psi-game :games-played] (fnil + 0) 1)
25 |   (swap! state assoc-in [:psi side] bet)
26 |   (let [opponent (if (= side :corp) :runner :corp)]
27 |     (if-let [opponent-bet (get-in @state [:psi opponent])]
28 |       (wait-for
29 |         (pay state opponent (make-eid state eid) card [(->c :credit opponent-bet)])
30 |         (system-msg state opponent (:msg async-result))
31 |         (wait-for
32 |           (pay state side (make-eid state eid) card (->c :credit bet))
33 |           (system-msg state side (:msg async-result))
34 |           (clear-wait-prompt state opponent)
35 |           (wait-for (trigger-event-simult state side (make-eid state eid) :reveal-spent-credits nil (get-in @state [:psi :corp]) (get-in @state [:psi :runner]))
36 |                     (let [card-side (if (corp? card) :corp :runner)]
37 |                       (if-let [ability (if (= bet opponent-bet) (:equal psi) (:not-equal psi))]
38 |                         (do (swap! state update-in [:stats card-side :psi-game :wins] (fnil + 0) 1)
39 |                             (continue-ability state card-side (assoc ability :async true) card targets))
40 |                         (do
41 |                           (swap! state update-in [:stats (if (= card-side :corp) :runner :corp) :psi-game :wins] (fnil + 0) 1)
42 |                           (effect-completed state side eid)))))))
43 |       (show-wait-prompt
44 |         state side (str (string/capitalize (name opponent)) " to choose psi game credits")))))
45 |
46 | (defn psi-game
47 |   "Starts a psi game by showing the psi prompt to both players. psi is a map containing
48 |   :equal and :not-equal abilities which will be triggered in resolve-psi accordingly."
49 |   ([state side card psi] (psi-game state side (make-eid state {:source-type :psi}) card psi nil))
50 |   ([state side eid card psi targets]
51 |    (swap! state assoc :psi {})
52 |    (register-once state side psi card)
53 |    (let [eid (assoc eid :source-type :psi)]
54 |      (doseq [s [:corp :runner]]
55 |        (let [all-amounts (range (min 3 (inc (total-available-credits state s eid card))))\
56 |              valid-amounts (remove #(or (any-flag-fn? state :corp :prevent-secretly-spend %)\
57 |                                         (any-flag-fn? state :runner :prevent-secretly-spend %))\
58 |                                    all-amounts)]
59 |          (show-prompt-with-dice state s card (str "Choose an amount to spend for " (:title card))
60 |                                 (map #(str % " [Credits]") valid-amounts)
61 |                                 #(resolve-psi state s eid card psi (str->int (first (string/split (:value %) #" "))) targets)
62 |                                 {:prompt-type :psi}))))))
63 |
64 | (defn- check-psi
65 |   "Checks if a psi-game is to be resolved"
66 |   [state side {:keys [eid psi] :as ability} card targets]
67 |   (assert (not (contains? psi :async)) "Put :async in the :equal/:not-equal.")
68 |   (if (can-trigger? state side eid psi card targets)
69 |     (resolve-ability
70 |       state side
71 |       (-> ability
72 |           (dissoc :psi :once :req)
73 |           (assoc :async true
74 |                  :effect (effect (psi-game eid card psi targets))))
75 |       card targets)
76 |     (effect-completed state side eid)))
77 |
78 | (register-ability-type :psi #'check-psi)
79 |

--------------------------------------------------------------------------------
/src/clj/game/core/purging.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.purging
 2 |   (:require
 3 |     [game.core.board :refer [get-all-installed]]
 4 |     [game.core.card :refer [get-counters]]
 5 |     [game.core.eid :refer [effect-completed]]
 6 |     [game.core.effects :refer [get-effects]]
 7 |     [game.core.engine :refer [queue-event checkpoint]]
 8 |     [game.core.ice :refer [update-all-ice]]
 9 |     [game.core.props :refer [add-counter]]
10 |     [game.macros :refer [wait-for]]))
11 |
12 | (defn- remove-virus-counters [state side eid [{:keys [card quantity] :as current} & remainder]]
13 |   (if-not current
14 |     (effect-completed state side eid)
15 |     (wait-for (add-counter state :runner card :virus (- quantity))
16 |               (remove-virus-counters state side eid remainder))))
17 |
18 | (defn purge
19 |   "Purges viruses."
20 |   [state side eid]
21 |   (let [purge-preventions\
22 |         (->> (get-effects state side :prevent-purge-virus-counters)\
23 |              (reduce\
24 |                (fn [acc cur]\
25 |                  (assoc acc (-> cur :card :cid) cur))\
26 |                {}))\
27 |         cards-to-purge\
28 |         (->> (get-all-installed state)\
29 |              (keep (fn [card]\
30 |                      (let [qty (get-counters card :virus)\
31 |                            pp (get purge-preventions (:cid card))\
32 |                            qty (if pp\
33 |                                  (- qty (:quantity pp 0))\
34 |                                  qty)]\
35 |                        (when (pos? qty)\
36 |                          {:card card :quantity qty}))))\
37 |              (vec))]
38 |     (wait-for
39 |       (remove-virus-counters state side cards-to-purge)
40 |       ;; (doseq [{:keys [card quantity]} cards-to-purge]
41 |       ;; (add-counter state :runner card :virus (- quantity)))
42 |       (update-all-ice state side)
43 |       (let [total-purged-counters (reduce + 0 (mapv :quantity cards-to-purge))]
44 |         (queue-event state :purge {:total-purged-counters total-purged-counters
45 |                                    :purges cards-to-purge})
46 |         (checkpoint state side eid)))))
47 |

--------------------------------------------------------------------------------
/src/clj/game/core/revealing.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.revealing
 2 |   (:require
 3 |    [clojure.string :as string]
 4 |    [game.core.eid :refer [effect-completed]]
 5 |    [game.core.engine :refer [queue-event checkpoint]]
 6 |    [game.core.say :refer [system-msg]]
 7 |    [game.core.servers :refer [name-zone]]
 8 |    [game.utils :refer [enumerate-str]]
 9 |    [jinteki.utils :refer [other-side]]))
10 |
11 | (defn reveal-hand
12 |   "Reveals a side's hand to opponent and spectators."
13 |   [state side]
14 |   (swap! state assoc-in [side :openhand] true))
15 |
16 | (defn conceal-hand
17 |   "Conceals a side's revealed hand from opponent and spectators."
18 |   [state side]
19 |   (swap! state update side dissoc :openhand))
20 |
21 | ;; TODO - find a way to condense these into one fn
22 | (defn reveal-and-queue-event
23 |   [state side & targets]
24 |   (let [cards (flatten targets)]
25 |     (swap! state assoc :last-revealed cards)
26 |     (queue-event state (if (= :corp side) :corp-reveal :runner-reveal) {:cards cards})))
27 |
28 | (defn reveal
29 |   "Trigger the event for revealing one or more cards."
30 |   [state side eid & targets]
31 |   (reveal-and-queue-event state side [targets])
32 |   (checkpoint state side eid))
33 |
34 | (defn reveal-loud
35 |   "Trigger the event for revealing one or more cards, and also handle the log printout"
36 |   [state side eid card {:keys [forced and-then no-event] :as args} & targets]
37 |   (let [cards-by-zone (group-by #(select-keys % [:side :zone]) (flatten targets))\
38 |         strs (map #(str (enumerate-str (map :title (get cards-by-zone %)))\
39 |                         " from " (name-zone (:side %) (:zone %)))\
40 |                   (keys cards-by-zone))\
41 |         ;; it's awkward to template a string that could refer to one or many\
42 |         ;; like "add it to the top of the stack" vs "add them to the top of the stack"\
43 |         ;; so I'm choosing to match the tokens [it] and [them] for this purpose\
44 |         plural-repr (if (< 1 (count (flatten targets))) "them" "it")\
45 |         follow-up (when and-then (string/replace and-then #"(\[it\])|(\[them\])" plural-repr))]
46 |     (if forced
47 |       (system-msg state (other-side side) (str "uses " (:title card) " to force the "
48 |                                                (string/capitalize (name side)) " to reveal "
49 |                                                (enumerate-str strs) follow-up))
50 |       (system-msg state side (str "uses " (:title card) " to reveal " (enumerate-str strs) follow-up)))
51 |     (if-not no-event
52 |       (reveal state side eid targets)
53 |       (effect-completed state side eid))))
54 |

--------------------------------------------------------------------------------
/src/clj/game/core/rezzing.clj:
--------------------------------------------------------------------------------
  1 | (ns game.core.rezzing
  2 |   (:require
  3 |     [game.core.card :refer [asset? condition-counter? get-card ice? upgrade?]]
  4 |     [game.core.card-defs :refer [card-def]]
  5 |     [game.core.cost-fns :refer [rez-additional-cost-bonus rez-cost]]
  6 |     [game.core.effects :refer [is-disabled? unregister-static-abilities update-disabled-cards]]
  7 |     [game.core.eid :refer [complete-with-result effect-completed make-eid]]
  8 |     [game.core.engine :refer [register-pending-event queue-event checkpoint pay register-events resolve-ability trigger-event unregister-events]]
  9 |     [game.core.flags :refer [can-host? can-rez?]]
 10 |     [game.core.ice :refer [update-ice-strength]]
 11 |     [game.core.initializing :refer [card-init deactivate]]
 12 |     [game.core.moving :refer [trash-cards]]
 13 |     [game.core.payment :refer [build-spend-msg can-pay? merge-costs ->c]]
 14 |     [game.core.runs :refer [continue]]
 15 |     [game.core.say :refer [play-sfx system-msg implementation-msg]]
 16 |     [game.core.toasts :refer [toast]]
 17 |     [game.core.to-string :refer [card-str]]
 18 |     [game.core.update :refer [update!]]
 19 |     [game.macros :refer [continue-ability effect wait-for]]
 20 |     [game.utils :refer [enumerate-str to-keyword]]))
 21 |
 22 | (defn get-rez-cost
 23 |   [state side card {:keys [ignore-cost alternative-cost cost-bonus]}]
 24 |   (merge-costs
 25 |     (cond
 26 |       (= :all-costs ignore-cost) [(->c :credit 0)]
 27 |       alternative-cost (when-not (is-disabled? state side card) alternative-cost)
 28 |       :else (let [cost (rez-cost state side card {:cost-bonus cost-bonus})\
 29 |                   additional-costs (rez-additional-cost-bonus state side card (when ignore-cost #(not= :credit (:cost/type %))))]
 30 |               (concat
 31 |                 (when-not ignore-cost
 32 |                   [(->c :credit cost)])
 33 |                 (when (not (:disabled card))
 34 |                   additional-costs))))))
 35 |
 36 | (defn trash-hosted-cards
 37 |   [state side eid card]
 38 |   (let [hosted-cards (seq (remove condition-counter? (:hosted card)))]
 39 |     (if (can-host? state card)
 40 |       (effect-completed state side eid)
 41 |       (wait-for (trash-cards state side hosted-cards {:unpreventable true :game-trash true})
 42 |                 (when (pos? (count hosted-cards))
 43 |                   (system-msg state side (str "trashes " (enumerate-str (map #(card-str state %) hosted-cards))
 44 |                                               " because " (:title card)
 45 |                                               " cannot host cards")))
 46 |                 (effect-completed state side eid)))))
 47 |
 48 | (defn- complete-rez
 49 |   [state side eid\
 50 |    {:keys [disabled] :as card}\
 51 |    {:keys [alternative-cost ignore-cost no-warning no-msg press-continue] :as args}]
 52 |   (let [cdef (card-def card)\
 53 |         costs (get-rez-cost state side card args)]
 54 |     (wait-for (pay state side (make-eid state eid) card costs)
 55 |               (let [{:keys [msg cost-paid]} async-result]
 56 |                 (if-not msg
 57 |                   (effect-completed state side eid)
 58 |                   (let [_ (when (:derezzed-events cdef)\
 59 |                             (unregister-events state side card))\
 60 |                         card (if disabled\
 61 |                                (update! state side (assoc card :rezzed :this-turn))\
 62 |                                (card-init state side (assoc card :rezzed :this-turn) {:resolve-effect false :init-data true}))]
 63 |                     (doseq [h (:hosted card)]
 64 |                       (update! state side (-> h
 65 |                                               (update-in [:zone] #(map to-keyword %))
 66 |                                               (update-in [:host :zone] #(map to-keyword %)))))
 67 |                     (when-not no-msg
 68 |                       (system-msg state side
 69 |                                   (str (build-spend-msg msg "rez" "rezzes")
 70 |                                        (:title card)
 71 |                                        (cond
 72 |                                          alternative-cost " by paying its alternative cost"
 73 |                                          ignore-cost " at no cost")))
 74 |                       (implementation-msg state card))
 75 |                     (when (and (not no-warning) (:corp-phase-12 @state))
 76 |                       (toast state :corp "You are not allowed to rez cards between Start of Turn and Mandatory Draw.
 77 |                                          Please rez prior to clicking Start Turn in the future." "warning"
 78 |                              {:time-out 0 :close-button true}))
 79 |                     (let [rez-byte (:rez-sound (card-def card))]
 80 |                       (if (ice? card)
 81 |                         (do (update-ice-strength state side card)
 82 |                             (when-not (:silent args) (play-sfx state side (or rez-byte "rez-ice"))))
 83 |                       (when-not (:silent args) (play-sfx state side (or rez-byte "rez-other")))))
 84 |                     (swap! state update-in [:stats :corp :cards :rezzed] (fnil inc 0))
 85 |                     (when-let [card-ability (:on-rez cdef)]
 86 |                       (register-pending-event state :rez card card-ability))
 87 |                     (queue-event state :rez {:card (get-card state card)
 88 |                                              :cost cost-paid})
 89 |                     (wait-for
 90 |                       (trash-hosted-cards state side (make-eid state eid) (get-card state card))
 91 |                       (wait-for
 92 |                         (checkpoint state nil (make-eid state eid) {:duration :rez})
 93 |                         (when press-continue
 94 |                           (continue state side nil))
 95 |                         (complete-with-result state side eid {:card (get-card state card)})))))))))
 96 |
 97 | (defn can-pay-to-rez?
 98 |   ([state side eid card] (can-pay-to-rez? state side eid card nil))
 99 |   ([state side eid card args]
100 |    (let [eid (assoc eid :source-type :rez)\
101 |          card (get-card state card)\
102 |          costs (or (get-rez-cost state side card args) 0)\
103 |          alternative-cost (when (and card\
104 |                                      (not (is-disabled? state side card)))\
105 |                             (:alternative-cost (card-def card)))]
106 |      (or (and alternative-cost
107 |               (can-pay? state side eid card nil alternative-cost))
108 |          (can-pay? state side eid card nil costs)))))
109 |
110 | (defn rez
111 |   "Rez a corp card."
112 |   ([state side eid card] (rez state side eid card nil))
113 |   ([state side eid card\
114 |     {:keys [ignore-cost force declined-alternative-cost alternative-cost] :as args}]
115 |    (let [eid (assoc eid :source-type :rez)\
116 |          card (get-card state card)\
117 |          alternative-cost (when (and card\
118 |                                      (not alternative-cost)\
119 |                                      (not (is-disabled? state side card))\
120 |                                      (not declined-alternative-cost))\
121 |                             (:alternative-cost (card-def card)))]
122 |      (if (and card
123 |               (or force
124 |                   (can-rez? state side card))
125 |               (or (asset? card)
126 |                   (ice? card)
127 |                   (upgrade? card)
128 |                   (:install-rezzed (card-def card))))
129 |        (if (and alternative-cost
130 |                 (not ignore-cost)
131 |                 (can-pay? state side eid card nil alternative-cost))
132 |          (continue-ability
133 |            state side
134 |            {:optional
135 |             {:prompt "Pay the alternative Rez cost?"
136 |              :yes-ability {:async true
137 |                            :effect (effect (rez eid card (merge args {:ignore-cost true
138 |                                                                       :alternative-cost alternative-cost})))}
139 |              :no-ability {:async true
140 |                           :effect (effect (rez eid card (merge args {:declined-alternative-cost true})))}}}
141 |            card nil)
142 |          (complete-rez state side eid card args))
143 |        (effect-completed state side eid)))))
144 |
145 | ;; TODO: make async
146 | (defn derez
147 |   "Derez a corp card."
148 |   ([state side card] (derez state side card nil))
149 |   ([state side card {:keys [source-card no-msg] :as args}]
150 |    (let [card (get-card state card)]
151 |      (when-not no-msg
152 |        (system-msg state side (str (if source-card
153 |                                      (str "uses " (:title source-card) " to derez ")
154 |                                      "derezzes ")
155 |                                    (:title card))))
156 |      (unregister-events state side card)
157 |      (update! state :corp (deactivate state :corp card true))
158 |      (let [cdef (card-def card)]
159 |        (when-let [derez-effect (:derez-effect cdef)]
160 |          (resolve-ability state side derez-effect (get-card state card) nil))
161 |        (when-let [derezzed-events (:derezzed-events cdef)]
162 |          (register-events state side card (map #(assoc % :condition :derezzed) derezzed-events))))
163 |      (unregister-static-abilities state side card)
164 |      (update-disabled-cards state)
165 |      (trigger-event state side :derez {:card card :side side}))))
166 |

--------------------------------------------------------------------------------
/src/clj/game/core/sabotage.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.sabotage
 2 |   (:require
 3 |     [clojure.string :as string]
 4 |     [game.core.card :refer [corp? in-hand?]]
 5 |     [game.core.eid :refer [effect-completed]]
 6 |     [game.core.engine :refer [resolve-ability]]
 7 |     [game.core.moving :refer [trash-cards]]
 8 |     [game.core.say :refer [system-msg]]
 9 |     [game.macros :refer [req msg continue-ability]]
10 |     [game.utils :refer [pluralize]]))
11 |
12 | (defn choosing-prompt-req
13 |   [n]
14 |   (req
15 |     (let [cards-rd (count (get-in @state [:corp :deck]))\
16 |           forced-hq (- n cards-rd)]
17 |       (str "Choose"
18 |            (when (pos? forced-hq)
19 |              (str " at least " forced-hq " " (pluralize "card" forced-hq) " and"))
20 |            " up to " n " " (pluralize "card" n)
21 |            " to trash from HQ. Remainder will be trashed from top of R&D."))))
22 |
23 | (defn trash-selected-req
24 |   [n]
25 |   (req
26 |     (let [targets (if (nil? target) [] targets) ; catch cancel-effect that gives [nil] as targets\
27 |           selected-hq (count targets)\
28 |           selected-rd (min (count (:deck corp))\
29 |                            (- n selected-hq))\
30 |           to-trash (concat targets (take selected-rd (:deck corp)))]
31 |       (system-msg state side
32 |                   (str
33 |                     "trashes"
34 |                     (when (pos? selected-hq)
35 |                       (str " " selected-hq " " (pluralize "card" selected-hq) " from HQ"))
36 |                     (when (and (pos? selected-hq) (pos? selected-rd))
37 |                       " and")
38 |                     (when (pos? selected-rd)
39 |                       (str " " selected-rd " " (pluralize "card" selected-rd) " from the top of R&D"))))
40 |       (trash-cards state side eid to-trash {:unpreventable true}))))
41 |
42 | (defn sabotage-ability
43 |   [n]
44 |   (let [choosing-ab (fn [forced-hq]\
45 |                       ^:ignore-async-check\
46 |                       {:waiting-prompt true\
47 |                        :player :corp\
48 |                        :prompt (choosing-prompt-req n)\
49 |                        :choices {:min forced-hq\
50 |                                  :max n\
51 |                                  :card #(and (corp? %)\
52 |                                              (in-hand? %))}\
53 |                        :async true\
54 |                        :cancel-effect (trash-selected-req n)\
55 |                        :effect (trash-selected-req n)})\
56 |         check-forcing-ab {:async true\
57 |                           :effect (req\
58 |                                     (let [cards-rd (count (:deck corp))\
59 |                                           cards-hq (count (:hand corp))\
60 |                                           forced-hq (- n cards-rd)]\
61 |                                       (if (>= n (+ cards-rd cards-hq))\
62 |                                         ((trash-selected-req n) state :corp eid card (:hand corp))\
63 |                                         (continue-ability state side\
64 |                                                           (choosing-ab forced-hq)\
65 |                                                           card nil))))}]
66 |     {:req (req (pos? n))
67 |      :msg (msg "sabotage " n)
68 |      :async true
69 |      :effect (req
70 |                (swap! state update-in [:stats :runner :cards-sabotaged] (fnil + 0) n)
71 |                (continue-ability state side check-forcing-ab card targets))}))
72 |

--------------------------------------------------------------------------------
/src/clj/game/core/say.clj:
--------------------------------------------------------------------------------
  1 | (ns game.core.say
  2 |   (:require
  3 |    [cljc.java-time.instant :as inst]
  4 |    [clojure.string :as str]
  5 |    [game.core.toasts :refer [toast]]))
  6 |
  7 | (defn make-message
  8 |   "Create a message map, along with timestamp if none is provided."
  9 |   [{:keys [user text timestamp]\
 10 |     :or {timestamp (inst/now)}}]
 11 |   {:user (if (= "__system__" user) user (select-keys user [:username :emailhash]))
 12 |    :text (if (string? text) (str/trim text) text)
 13 |    :timestamp timestamp})
 14 |
 15 | (defn make-system-message
 16 |   "Creates a message map from the __system__ user, which won't display a username."
 17 |   [text]
 18 |   (make-message {:user "__system__" :text text}))
 19 |
 20 | (defn- select-pronoun
 21 |   "Selects an appropriate plurular pronoun
 22 |   'their' is neuter, so it's appropriate to everyone as a fallback"
 23 |   [user]
 24 |   (let [key (get-in user [:options :pronouns])]
 25 |     (case key
 26 |       "she" "her"
 27 |       "he" "his"
 28 |       "it" "its"
 29 |       "heit" "its"
 30 |       "sheit" "its"
 31 |       "their")))
 32 |
 33 | (defn- insert-pronouns
 34 |   "inserts pronouns into text based on the side speaking"
 35 |   [state side text]
 36 |   (let [corp-pronoun (select-pronoun (get-in @state [:corp :user]))\
 37 |         runner-pronoun (select-pronoun (get-in @state [:runner :user]))\
 38 |         user-pronoun (cond\
 39 |                        (= side :corp) corp-pronoun\
 40 |                        (= side :runner) runner-pronoun\
 41 |                        :else "their")]
 42 |     (-> text
 43 |         (str/replace #"(\[pronoun\])|(\[their\])" user-pronoun)
 44 |         (str/replace #"\[corp-pronoun\]" corp-pronoun)
 45 |         (str/replace #"\[runner-pronoun\]" runner-pronoun))))
 46 |
 47 | (defn say
 48 |   "Prints a message to the log as coming from the given user."
 49 |   [state side {:keys [user text]}]
 50 |   (let [author (or user (get-in @state [side :user]))\
 51 |         message (make-message {:user author :text (insert-pronouns state side text)})]
 52 |     (swap! state update :log conj message)
 53 |     (swap! state assoc :typing false)))
 54 |
 55 | (defn system-say
 56 |   "Prints a system message to log (`say` from user __system__)"
 57 |   ([state side text] (system-say state side text nil))
 58 |   ([state side text {:keys [hr]}]
 59 |    (say state side (make-system-message (str text (when hr "[hr]"))))))
 60 |
 61 | (defn unsafe-say
 62 |   "Prints a reagent hiccup directly to the log. Do not use for any user-generated content!"
 63 |   [state text]
 64 |   (let [message (make-system-message text)]
 65 |     (swap! state update :log conj message)))
 66 |
 67 | (defn system-msg
 68 |   "Prints a message to the log without a username."
 69 |   ([state side text] (system-msg state side text nil))
 70 |   ([state side text args]
 71 |    (let [username (get-in @state [side :user :username])]
 72 |      (system-say state side (str username " " text ".") args))))
 73 |
 74 | (defn enforce-msg
 75 |   "Prints a message related to a rules enforcement on a given card.
 76 |   Example: 'Architect cannot be trashed while installed.'"
 77 |   [state card text]
 78 |   (system-say state nil (str (:title card) " " text ".")))
 79 |
 80 | (defn implementation-msg
 81 |   [state card]
 82 |   (when (not= :full (:implementation card))
 83 |     (system-say state nil (str "[!] " (:title card) " - " (:implementation card)))))
 84 |
 85 | (defn indicate-action
 86 |   [state side _]
 87 |   (system-say state side
 88 |               (str "[!] Please pause, " (if (= side :corp) "Corp" "Runner") " is acting."))
 89 |   (toast state side
 90 |          "You have indicated action to your opponent"
 91 |          "info"
 92 |          {:time-out 2000 :close-button false})
 93 |   (toast state (if (= side :corp) :runner :corp)
 94 |          "Pause please, opponent is acting"
 95 |          "info"
 96 |          {:time-out 5000 :close-button true}))
 97 |
 98 | (defn play-sfx
 99 |   "Adds a sound effect to play to the sfx queue.
100 |   Each SFX comes with a unique ID, so each client can track for themselves which sounds have already been played.
101 |   The sfx queue has size limited to 3 to limit the sound torrent tabbed out or lagged players will experience."
102 |   [state _ sfx]
103 |   (swap! state (fn [state]
104 |                  (if-let [current-id (:sfx-current-id state)]
105 |                    (-> state
106 |                        (update :sfx conj {:id (inc current-id) :name sfx})
107 |                        (update :sfx #(take 3 %))
108 |                        (update :sfx-current-id inc))
109 |                    state))))
110 |

--------------------------------------------------------------------------------
/src/clj/game/core/servers.clj:
--------------------------------------------------------------------------------
  1 | (ns game.core.servers
  2 |   "Utility functions for working with servers and zones"
  3 |   (:require
  4 |     [game.core.card :refer [get-zone]]
  5 |     [game.utils :refer [safe-split string->num]]
  6 |     [clojure.string :as string]))
  7 |
  8 | (defn target-server
  9 |   "Returns the server keyword corresponding to the target of a run."
 10 |   [run]
 11 |   (first (:server run)))
 12 |
 13 | (defn remote-num->name
 14 |   [num]
 15 |   (str "Server " num))
 16 |
 17 | (defn remote->name
 18 |   "Converts a remote zone to a string"
 19 |   [zone]
 20 |   (let [kw (if (keyword? zone) zone (last zone))\
 21 |         s (str kw)]
 22 |     (when (string/starts-with? s ":remote")
 23 |       (let [num (last (string/split s #":remote"))]
 24 |         (remote-num->name num)))))
 25 |
 26 | (defn central->name
 27 |   "Converts a central zone keyword to a string."
 28 |   [zone]
 29 |   (case (if (keyword? zone) zone (last zone))
 30 |     (:hand :hq) "HQ"
 31 |     (:deck :rd) "R&D"
 32 |     (:discard :archives) "Archives"
 33 |     nil))
 34 |
 35 | (defn zone->name
 36 |   "Converts a zone to a string."
 37 |   [zone]
 38 |   (or (central->name zone)
 39 |       (remote->name zone)))
 40 |
 41 | (defn name-zone
 42 |   "Gets a string representation for the given zone."
 43 |   [side zone]
 44 |   (let [side (cond (= :corp side) "Corp"\
 45 |                    (= :runner side) "Runner"\
 46 |                    :else side)\
 47 |         zone (if (keyword? zone) [zone] (vec zone))]
 48 |   (cond
 49 |     (= zone [:hand]) (if (= side "Runner") "the Grip" "HQ")
 50 |     (= zone [:discard]) (if (= side "Runner") "the Heap" "Archives")
 51 |     (= zone [:deck]) (if (= side "Runner") "the Stack" "R&D")
 52 |     (= zone [:set-aside]) "set-aside cards"
 53 |     (= (take 1 zone) [:rig]) "Rig"
 54 |     (= (take 2 zone) [:servers :hq]) "the root of HQ"
 55 |     (= (take 2 zone) [:servers :rd]) "the root of R&D"
 56 |     (= (take 2 zone) [:servers :archives]) "the root of Archives"
 57 |     :else (zone->name (second zone)))))
 58 |
 59 | (defn zone->sort-key
 60 |   [zone]
 61 |   (case (if (keyword? zone) zone (last zone))
 62 |     :archives -3
 63 |     :rd -2
 64 |     :hq -1
 65 |     (string->num
 66 |       (last (safe-split (str zone) #":remote")))))
 67 |
 68 | (defn zones->sorted-names
 69 |   [zones]
 70 |   (->> zones (sort-by zone->sort-key) (map zone->name)))
 71 |
 72 | (defn is-remote?
 73 |   "Returns true if the zone is for a remote server"
 74 |   [zone]
 75 |   (some? (remote->name zone)))
 76 |
 77 | (defn is-central?
 78 |   "Returns true if the zone is for a central server"
 79 |   [zone]
 80 |   (not (is-remote? zone)))
 81 |
 82 | (defn is-root?
 83 |   "Returns true if the zone is root a central server"
 84 |   [zone]
 85 |   (and (is-central? (second zone))
 86 |        (= :content (last zone))))
 87 |
 88 | (defn central->zone
 89 |   "Converts a central server keyword like :discard into a corresponding zone vector"
 90 |   [zone]
 91 |   (case (if (keyword? zone) zone (last zone))
 92 |     :discard [:servers :archives]
 93 |     :hand [:servers :hq]
 94 |     :deck [:servers :rd]
 95 |     nil))
 96 |
 97 | (defn type->rig-zone
 98 |   "Converts a runner's card type to a vector zone, e.g. 'Program' -> [:rig :program]"
 99 |   [type]
100 |   (vec [:rig (-> type string/lower-case keyword)]))
101 |
102 | (defn get-server-type
103 |   [zone]
104 |   (or (#{:hq :rd :archives} zone) :remote))
105 |
106 | (defn same-server?
107 |   "True if the two cards are IN or PROTECTING the same server."
108 |   [card1 card2]
109 |   (and card1
110 |        card2
111 |        (let [zone1 (get-zone card1)\
112 |              zone2 (get-zone card2)]
113 |          (= (second zone1) (second zone2)))))
114 |
115 | (defn protecting-same-server?
116 |   "True if an ice is protecting the server that the card is in or protecting."
117 |   [card ice]
118 |   (and card
119 |        ice
120 |        (let [zone1 (get-zone card)\
121 |              zone2 (get-zone ice)]
122 |          (and (= (second (or (central->zone zone1) zone1))
123 |                  (second zone2))
124 |               (= :ices (last zone2))))))
125 |
126 | (defn in-same-server?
127 |   "True if the two cards are installed IN the same server, or hosted on cards IN the same server."
128 |   [card1 card2]
129 |   (let [zone1 (get-zone card1)\
130 |         zone2 (get-zone card2)]
131 |     (and card1
132 |          card2
133 |          (= zone1 zone2)
134 |          (= :content (last zone1)))))
135 |
136 | (defn from-same-server?
137 |   "True if the upgrade is in the root of the server that the target is in."
138 |   [upgrade target]
139 |   (and (:cid upgrade)
140 |        (:cid target)
141 |        (= (central->zone (:zone target))
142 |           (butlast (get-zone upgrade)))))
143 |
144 | (defn unknown->kw
145 |   "Given a string ('Archives'), a keyword corresponding to a server (:archives)
146 |   or a zone ([:servers :archives]), return the keyword.
147 |   NOTE: return keyword even if server does not exist."
148 |   [name-or-kw-or-zone]
149 |   (cond
150 |     (keyword? name-or-kw-or-zone)
151 |     name-or-kw-or-zone
152 |
153 |     (string? name-or-kw-or-zone)
154 |     (case name-or-kw-or-zone
155 |       "HQ" :hq
156 |       "R&D" :rd
157 |       "Archives" :archives
158 |       ;; assume "Server N"
159 |       (->> (string/split name-or-kw-or-zone #" ") last (str "remote") keyword))
160 |
161 |     :else
162 |     (second name-or-kw-or-zone)))
163 |

--------------------------------------------------------------------------------
/src/clj/game/core/set_aside.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.set-aside
 2 |   (:require
 3 |     [game.core.card :refer [in-set-aside?]]
 4 |     [game.core.eid :refer [effect-completed]]
 5 |     [game.core.moving :refer [move swap-cards]]
 6 |     [game.utils :refer [dissoc-in]]
 7 |     [clojure.string :as string]))
 8 |
 9 | (defn set-aside
10 |   "move a group of cards to the set-aside zone. Does not call effect-completed on the eid"
11 |   ([state side eid cards] (set-aside state side eid cards true true))
12 |   ([state side eid cards corp-vis runner-vis]
13 |    (swap! state assoc-in [side :set-aside-tracking (:eid eid)] (map :cid cards))
14 |    (mapv #(move state side (assoc % :set-aside-visibility {:corp-can-see corp-vis :runner-can-see runner-vis}
15 |                                   :set-aside-eid eid) :set-aside)
16 |          cards)))
17 |
18 | (defn set-aside-for-me
19 |   "sets aside cards visible only to the player setting them aside"
20 |   ([state side eid cards]
21 |    (if (= side :runner)
22 |      (set-aside state side eid cards nil true)
23 |      (set-aside state side eid cards true nil))))
24 |
25 | (defn get-set-aside
26 |   "gets all the cards currently set aside in the given players set-aside zone with tracked with this eid"
27 |   [state side eid]
28 |   (let [eid (:eid eid)\
29 |         cids (set (get-in @state [side :set-aside-tracking eid]))\
30 |         player (get @state side)]
31 |     (->> (:set-aside player)
32 |          (filter #(contains? cids (:cid %)))
33 |          (into []))))
34 |
35 | (defn clean-set-aside!
36 |   "cleans stale entries out of the set aside tracker"
37 |   [state side]
38 |   (let [to-clear (filter #(empty? (get-set-aside state side {:eid %})) (keys (get-in @state [side :set-aside-tracking])))]
39 |     (doseq [eid to-clear]
40 |       (swap! state dissoc-in [side :set-aside-tracking eid]))))
41 |
42 | ;; adds a card into the set aside zone using a given cid (ie add it to the set of cards in a draw)
43 | (defn add-to-set-aside
44 |   "Adds a card into an existing set-aside eid tracker"
45 |   [state side eid card visibility]
46 |   (set-aside state side eid
47 |              (conj (get-set-aside state side eid) card)
48 |              (:corp-can-see visibility) (:runner-can-see visibility)))
49 |
50 | (defn swap-set-aside-cards
51 |   "Swaps two cards when one or both aren't installed"
52 |   [state side a b]
53 |   (let [swapped-cards (swap-cards state side a b)\
54 |         a-moved (first swapped-cards)\
55 |         b-moved (second swapped-cards)]
56 |     (when (in-set-aside? a)
57 |       (add-to-set-aside state side (:set-aside-eid a) b-moved (:set-aside-visibility a)))
58 |     (when (in-set-aside? b)
59 |       (add-to-set-aside state side (:set-aside-eid b) a-moved (:set-aside-visibility b)))))
60 |

--------------------------------------------------------------------------------
/src/clj/game/core/set_up.clj:
--------------------------------------------------------------------------------
  1 | (ns game.core.set-up
  2 |   (:require
  3 |    [cljc.java-time.instant :as inst]
  4 |    [game.core.card :refer [corp? runner?]]
  5 |    [game.core.card-defs :refer [card-def]]
  6 |    [game.core.checkpoint :refer [fake-checkpoint]]
  7 |    [game.core.diffs :refer [public-states]]
  8 |    [game.core.drawing :refer [draw]]
  9 |    [game.core.eid :refer [make-eid effect-completed]]
 10 |    [game.core.engine :refer [trigger-event trigger-event-sync]]
 11 |    [game.core.initializing :refer [card-init make-card]]
 12 |    [game.core.player :refer [new-corp new-runner]]
 13 |    [game.core.prompts :refer [clear-wait-prompt show-prompt show-wait-prompt]]
 14 |    [game.core.say :refer [system-msg system-say implementation-msg]]
 15 |    [game.core.shuffling :refer [shuffle-into-deck]]
 16 |    [game.core.state :refer [new-state]]
 17 |    [game.macros :refer [wait-for]]
 18 |    [game.quotes :as quotes]
 19 |    [game.utils :refer [server-card]]))
 20 |
 21 | (defn build-card
 22 |   [card]
 23 |   (let [s-card (or (server-card (:title card)) card)]
 24 |     (assoc (make-card s-card) :art (:art card))))
 25 |
 26 | (defn create-deck
 27 |   "Creates a shuffled draw deck (R&D/Stack) from the given list of cards.
 28 |   Loads card data from the server-card map if available."
 29 |   [deck]
 30 |   (shuffle (mapcat #(map build-card (repeat (:qty %) (assoc (:card %) :art (:art %))))
 31 |                    (shuffle (vec (:cards deck))))))
 32 |
 33 | ;;; Functions for the creation of games and the progression of turns.
 34 | (defn mulligan
 35 |   "Mulligan starting hand."
 36 |   [state side _]
 37 |   (shuffle-into-deck state side :hand)
 38 |   (draw state side (make-eid state) 5 {:suppress-event true :no-update-draw-stats true})
 39 |   (let [card (get-in @state [side :identity])]
 40 |     (when-let [cdef (card-def card)]
 41 |       (when-let [mul (:mulligan cdef)]
 42 |         (mul state side (make-eid state) card nil))))
 43 |   (swap! state assoc-in [side :keep] :mulligan)
 44 |   (system-msg state side "takes a mulligan")
 45 |   (trigger-event state side :pre-first-turn)
 46 |   (when (and (= side :corp) (-> @state :runner :identity :title))
 47 |     (clear-wait-prompt state :runner)
 48 |     (show-wait-prompt state :corp "Runner to keep hand or mulligan"))
 49 |   (when (and (= side :runner)  (-> @state :corp :identity :title))
 50 |     (clear-wait-prompt state :corp)))
 51 |
 52 | (defn keep-hand
 53 |   "Choose not to mulligan."
 54 |   [state side _]
 55 |   (swap! state assoc-in [side :keep] :keep)
 56 |   (system-msg state side "keeps [their] hand")
 57 |   (trigger-event state side :pre-first-turn)
 58 |   (when (and (= side :corp) (-> @state :runner :identity :title))
 59 |     (clear-wait-prompt state :runner)
 60 |     (show-wait-prompt state :corp "Runner to keep hand or mulligan"))
 61 |   (when (and (= side :runner)  (-> @state :corp :identity :title))
 62 |     (clear-wait-prompt state :corp)))
 63 |
 64 | (defn- init-hands [state]
 65 |   (draw state :corp (make-eid state) 5 {:suppress-event true})
 66 |   (draw state :runner (make-eid state) 5 {:suppress-event true})
 67 |   (doseq [side [:corp :runner]]
 68 |     (when (-> @state side :identity :title)
 69 |       (show-prompt state side nil "Keep hand?"
 70 |                    ["Keep" "Mulligan"]
 71 |                    #(if (= (:value %) "Keep")
 72 |                       (keep-hand state side nil)
 73 |                       (mulligan state side nil))
 74 |                    {:prompt-type :mulligan})))
 75 |   (when (and (-> @state :corp :identity :title)
 76 |              (-> @state :runner :identity :title))
 77 |     (show-wait-prompt state :runner "Corp to keep hand or mulligan")))
 78 |
 79 | (defn- init-game-state
 80 |   "Initialises the game state"
 81 |   [{:keys [players gameid timer spectatorhands api-access save-replay room] :as game}]
 82 |   (let [corp (some #(when (corp? %) %) players)\
 83 |         runner (some #(when (runner? %) %) players)\
 84 |         corp-deck (create-deck (:deck corp))\
 85 |         runner-deck (create-deck (:deck runner))\
 86 |         corp-deck-id (get-in corp [:deck :_id])\
 87 |         runner-deck-id (get-in runner [:deck :_id])\
 88 |         corp-options (get-in corp [:options])\
 89 |         runner-options (get-in runner [:options])\
 90 |         corp-identity (build-card (or (get-in corp [:deck :identity])\
 91 |                                       {:side "Corp"\
 92 |                                        :type "Identity"\
 93 |                                        :title "Custom Biotics: Engineered for Success"}))\
 94 |         runner-identity (build-card (or (get-in runner [:deck :identity])\
 95 |                                         {:side "Runner"\
 96 |                                          :type "Identity"\
 97 |                                          :title "The Professor: Keeper of Knowledge"}))\
 98 |         corp-quote (quotes/make-quote corp-identity runner-identity)\
 99 |         runner-quote (quotes/make-quote runner-identity corp-identity)\
100 |         fmt (:format game)]
101 |     (atom
102 |       (new-state
103 |         gameid
104 |         room
105 |         fmt
106 |         (inst/now)
107 |         {:timer timer
108 |          :spectatorhands spectatorhands
109 |          :api-access api-access
110 |          :save-replay save-replay}
111 |         (new-corp (:user corp) corp-identity corp-options (map #(assoc % :zone [:deck]) corp-deck) corp-deck-id corp-quote)
112 |         (new-runner (:user runner) runner-identity runner-options (map #(assoc % :zone [:deck]) runner-deck) runner-deck-id runner-quote)))))
113 |
114 | (defn- create-basic-action-cards
115 |   [state]
116 |   (swap! state
117 |          assoc-in [:corp :basic-action-card]
118 |          (make-card {:side "Corp"
119 |                      :type "Basic Action"
120 |                      :title "Corp Basic Action Card"}))
121 |   (swap! state
122 |          assoc-in [:runner :basic-action-card]
123 |          (make-card {:side "Runner"
124 |                      :type "Basic Action"
125 |                      :title "Runner Basic Action Card"})))
126 |
127 | (defn- set-deck-lists
128 |   [state]
129 |   (let [runner-cards (sort-by key (frequencies (map :title (get-in @state [:runner :deck]))))\
130 |         corp-cards (sort-by key (frequencies (map :title (get-in @state [:corp :deck]))))]
131 |     (swap! state assoc :decklists {:corp corp-cards :runner runner-cards})))
132 |
133 | (defn init-game
134 |   "Initializes a new game with the given players vector."
135 |   [game]
136 |   (let [state (init-game-state game)\
137 |         corp-identity (get-in @state [:corp :identity])\
138 |         runner-identity (get-in @state [:runner :identity])]
139 |     (when-let [messages (seq (:messages game))]
140 |       (swap! state assoc :log (into [] messages))
141 |       (system-say state nil "[hr]"))
142 |     (when (:open-decklists game)
143 |       (set-deck-lists state))
144 |     (card-init state :corp corp-identity)
145 |     (implementation-msg state corp-identity)
146 |     (card-init state :runner runner-identity)
147 |     (implementation-msg state runner-identity)
148 |     (create-basic-action-cards state)
149 |     (fake-checkpoint state)
150 |     (let [eid (make-eid state)]
151 |       (wait-for (trigger-event-sync state :corp :pre-start-game nil)
152 |                 (wait-for (trigger-event-sync state :runner :pre-start-game nil)
153 |                           (init-hands state)
154 |                           (fake-checkpoint state)
155 |                           (effect-completed state nil eid))))
156 |     (swap! state assoc :history [(:hist-state (public-states state))])
157 |     state))
158 |

--------------------------------------------------------------------------------
/src/clj/game/core/shuffling.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.shuffling
 2 |   (:require
 3 |    [game.core.card :refer [corp? in-discard?]]
 4 |    [game.core.eid :refer [effect-completed]]
 5 |    [game.core.engine :refer [trigger-event]]
 6 |    [game.core.moving :refer [move move-zone]]
 7 |    [game.core.say :refer [system-msg]]
 8 |    [game.macros :refer [continue-ability msg req]]
 9 |    [game.utils :refer [enumerate-str quantify]]))
10 |
11 | (defn shuffle!
12 |   "Shuffles the vector in @state [side kw]."
13 |   [state side kw]
14 |   (when (contains? #{:deck :hand :discard} kw)
15 |     (trigger-event state side (when (= :deck kw) (if (= :corp side) :corp-shuffle-deck :runner-shuffle-deck)))
16 |     (when (and (:access @state)
17 |                (:run @state)
18 |                (= :corp side)
19 |                (= :deck kw))
20 |       (swap! state assoc-in [:run :shuffled-during-access :rd] true))
21 |     (swap! state update-in [:stats side :shuffle-count] (fnil + 0) 1)
22 |     (swap! state update-in [side kw] shuffle)))
23 |
24 | (defn shuffle-into-deck
25 |   [state side & args]
26 |   (doseq [zone (filter keyword? args)]
27 |     (move-zone state side zone :deck))
28 |   (shuffle! state side :deck))
29 |
30 | (defn shuffle-into-rd-effect
31 |   ([state side eid card n] (shuffle-into-rd-effect state side eid card n false))
32 |   ([state side eid card n all?]
33 |    (continue-ability
34 |      state side
35 |      {:show-discard  true
36 |       :choices {:max (min (-> @state :corp :discard count) n)
37 |                 :card #(and (corp? %)
38 |                             (in-discard? %))
39 |                 :all all?}
40 |       :msg (msg "shuffle "
41 |                 (let [seen (filter :seen targets)\
42 |                       m (count (filter #(not (:seen %)) targets))]
43 |                   (str (enumerate-str (map :title seen))
44 |                        (when (pos? m)
45 |                          (str (when-not (empty? seen) " and ")
46 |                               (quantify m "unseen card")))))
47 |                 " into R&D")
48 |       :waiting-prompt true
49 |       :effect (req (doseq [c targets]
50 |                      (move state side c :deck))
51 |                    (shuffle! state side :deck))
52 |       :cancel-effect (req
53 |                       (system-msg state side (str " uses " (:title card) " to shuffle R&D"))
54 |                       (shuffle! state side :deck)
55 |                       (effect-completed state side eid))}
56 |      card nil)))
57 |
58 | (defn shuffle-deck
59 |   "Shuffle R&D/Stack."
60 |   [state side {:keys [close]}]
61 |   (swap! state update-in [side :deck] shuffle)
62 |   (if close
63 |     (do
64 |       (swap! state update-in [side] dissoc :view-deck)
65 |       (system-msg state side "stops looking at [pronoun] deck and shuffles it"))
66 |     (system-msg state side "shuffles [pronoun] deck")))
67 |

--------------------------------------------------------------------------------
/src/clj/game/core/state.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.state)
 2 |
 3 | (defrecord State
 4 |   [;; angel-arena-info\
 5 |    active-player\
 6 |    bonus\
 7 |    click-state\
 8 |    corp\
 9 |    corp-phase-12\
10 |    effects\
11 |    effect-completed\
12 |    eid\
13 |    encounters\
14 |    end-run\
15 |    end-time\
16 |    end-turn\
17 |    events\
18 |    format\
19 |    gameid\
20 |    history\
21 |    log\
22 |    loser\
23 |    losing-deck-id\
24 |    losing-user\
25 |    mark\
26 |    options\
27 |    per-run\
28 |    per-turn\
29 |    psi\
30 |    queued-events\
31 |    reason\
32 |    rid\
33 |    room\
34 |    run\
35 |    runner\
36 |    runner-phase-12\
37 |    sfx\
38 |    sfx-current-id\
39 |    stack\
40 |    start-date\
41 |    stats\
42 |    trace\
43 |    trash\
44 |    turn\
45 |    turn-events\
46 |    turn-state\
47 |    typing\
48 |    winner\
49 |    winning-deck-id\
50 |    winning-user])
51 |
52 | (defn make-rid
53 |   "Returns a progressively-increasing integer to identify a new remote server."
54 |   [state]
55 |   (let [current-rid (:rid @state)]
56 |     (swap! state update :rid inc)
57 |     current-rid))
58 |
59 | (defn new-state
60 |   [gameid room fmt now options corp runner]
61 |   (map->State
62 |     {:gameid gameid
63 |      :log []
64 |      :active-player :runner
65 |      :end-turn true
66 |      :format (keyword fmt)
67 |      :history []
68 |      :mark nil
69 |      :room room
70 |      :rid 1 :turn 0 :eid 0
71 |      :sfx [] :sfx-current-id 0
72 |      :stats {:time {:started now}}
73 |      :start-date now
74 |      :options options
75 |      :encounters []
76 |      :corp corp
77 |      :runner runner}))
78 |

--------------------------------------------------------------------------------
/src/clj/game/core/subtypes.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.subtypes
 2 |   (:require [game.core.board :refer [get-all-cards]]
 3 |             [game.core.card :refer [get-card]]
 4 |             [game.core.effects :refer [get-effects]]
 5 |             [game.core.update :refer [update!]]
 6 |             [game.utils :refer [server-card to-keyword]]))
 7 |
 8 | (defn subtypes-for-card
 9 |   "Creates a sorted list of subtypes for the card. Returns nil if given a counter or fake agenda."
10 |   [state card]
11 |   (when (:title card)
12 |     (let [printed-subtypes (:subtypes (server-card (:title card)))\
13 |           gained-subtypes (flatten (get-effects state nil :gain-subtype card))\
14 |           lost-subtypes (flatten (get-effects state nil :lose-subtype card))\
15 |           total-gained (frequencies (concat printed-subtypes gained-subtypes))\
16 |           total-lost (frequencies lost-subtypes)\
17 |           total (reduce\
18 |                   (fn [acc [k v]]\
19 |                     (let [cur (get acc k 0)\
20 |                           total (- cur v)]\
21 |                       (if (pos? total)\
22 |                         (assoc acc k total)\
23 |                         (dissoc acc k))))\
24 |                   total-gained\
25 |                   total-lost)]
26 |       (into [] (sort (keys total))))))
27 |
28 | (defn update-subtypes-for-card
29 |   [state _ card]
30 |   (let [card (get-card state card)\
31 |         old-subtypes (:subtypes card)\
32 |         new-subtypes (subtypes-for-card state card)\
33 |         changed? (not= old-subtypes new-subtypes)]
34 |     (when changed?
35 |       (update! state (to-keyword (:side card)) (assoc card :subtypes new-subtypes)))
36 |     changed?))
37 |
38 | (defn update-all-subtypes
39 |   ([state] (update-all-subtypes state nil))
40 |   ([state _]
41 |    (reduce
42 |      (fn [changed? card]
43 |        (or (update-subtypes-for-card state nil card)
44 |            changed?))
45 |      false
46 |      (get-all-cards state))))
47 |

--------------------------------------------------------------------------------
/src/clj/game/core/tags.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.tags
 2 |   (:require
 3 |     [game.core.effects :refer [any-effects sum-effects]]
 4 |     [game.core.eid :refer [effect-completed make-eid]]
 5 |     [game.core.engine :refer [trigger-event trigger-event-simult trigger-event-sync queue-event checkpoint]]
 6 |     [game.core.gaining :refer [deduct gain]]
 7 |     [game.core.prevention :refer [resolve-tag-prevention]]
 8 |     [game.core.prompts :refer [clear-wait-prompt show-prompt show-wait-prompt]]
 9 |     [game.core.say :refer [system-msg]]
10 |     [game.core.toasts :refer [toast]]
11 |     [game.macros :refer [wait-for]]
12 |     [game.utils :refer [pluralize quantify]]))
13 |
14 | (defn sum-tag-effects
15 |   [state]
16 |   (+ (or (get-in @state [:runner :tag :base]) 0)
17 |      (sum-effects state :runner :user-tags)
18 |      (sum-effects state :runner :tags)))
19 |
20 | (defn update-tag-status
21 |   ([state] (update-tag-status state nil))
22 |   ([state _]
23 |    (let [old-total (get-in @state [:runner :tag :total])\
24 |          new-total (sum-tag-effects state)\
25 |          is-tagged? (or (any-effects state :runner :is-tagged)\
26 |                         (pos? new-total))\
27 |          old-tags (select-keys (get-in @state [:runner :tag]) [:total :is-tagged])\
28 |          new-tags {:total new-total\
29 |                    :is-tagged is-tagged?}\
30 |          changed? (not= old-tags new-tags)]
31 |      (when changed?
32 |        (swap! state update-in [:runner :tag] merge new-tags)
33 |        (trigger-event state :runner :tags-changed {:new-total new-total
34 |                                                    :old-total old-total
35 |                                                    :is-tagged is-tagged?}))
36 |      changed?)))
37 |
38 | (defn- resolve-tag
39 |   "Resolve runner gain tags. Always gives `:base` tags."
40 |   [state side eid {:keys [card n suppress-checkpoint]}]
41 |   (if (pos? n)
42 |     (do (gain state :runner :tag {:base n})
43 |         (toast state :runner (str "Took " (quantify n "tag") "!") "info")
44 |         (update-tag-status state)
45 |         (queue-event state :runner-gain-tag {:side side
46 |                                              :cause-card (select-keys card [:cid :title])
47 |                                              :amount n}))
48 |     (queue-event state :runner-prevents-all-tags {:side side
49 |                                                   :cause-card card}))
50 |   (if suppress-checkpoint
51 |     (effect-completed state nil eid)
52 |     (checkpoint state eid)))
53 |
54 | (defn gain-tags
55 |   "Attempts to give the runner n tags, allowing for boosting/prevention effects."
56 |   ([state side eid n] (gain-tags state side eid n nil))
57 |   ([state side eid n {:keys [unpreventable card suppress-checkpoint] :as args}]
58 |    (wait-for
59 |      (resolve-tag-prevention state side n args)
60 |      (resolve-tag state side eid {:suppress-checkpoint suppress-checkpoint
61 |                                   :card card
62 |                                   :n (:remaining async-result)}))))
63 |
64 | (defn lose-tags
65 |   "Always removes `:base` tags"
66 |   ([state side eid n] (lose-tags state side eid n nil))
67 |   ([state side eid n {:keys [suppress-checkpoint] :as args}]
68 |    (if (= n :all)
69 |      (lose-tags state side eid (get-in @state [:runner :tag :base]))
70 |      (do (swap! state update-in [:stats :runner :lose :tag] (fnil + 0) n)
71 |          (deduct state :runner [:tag {:base n}])
72 |          (update-tag-status state)
73 |          (queue-event state :runner-lose-tag {:amount n
74 |                                               :side side})
75 |          (if suppress-checkpoint
76 |            (effect-completed state nil eid)
77 |            (checkpoint state eid))))))
78 |

--------------------------------------------------------------------------------
/src/clj/game/core/threat.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.threat
 2 |   (:require
 3 |     [clojure.string :as string]
 4 |     [game.core.card :refer [corp? in-hand?]]
 5 |     [game.core.eid :refer [effect-completed]]
 6 |     [game.core.engine :refer [resolve-ability]]
 7 |     [game.core.moving :refer [trash-cards]]
 8 |     [game.core.say :refer [system-msg]]
 9 |     [game.macros :refer [req msg continue-ability]]
10 |     [game.utils :refer [pluralize]]))
11 |
12 | (defn threat-level [threshold state]
13 |   ;; does the threat level meet or exceed the given threshold
14 |   (or (<= threshold (get-in @state [:runner :agenda-point]))
15 |       (<= threshold (get-in @state [:corp :agenda-point]))))
16 |
17 | (defn get-threat-level [state]
18 |   (max (get-in @state [:runner :agenda-point])
19 |        (get-in @state [:corp :agenda-point])))
20 |
21 | (defn threat
22 |   ([threshold accept-ab]
23 |    (threat threshold accept-ab nil))
24 |   ([threshold accept-ab reject-ab]
25 |    {:req (req true)
26 |     :async true
27 |     :effect (req (if (threat-level threshold state)
28 |                    (continue-ability state side accept-ab card targets)
29 |                    (if (nil? reject-ab)
30 |                      (effect-completed state side eid)
31 |                      (continue-ability state side reject-ab card targets))))}))
32 |

--------------------------------------------------------------------------------
/src/clj/game/core/to_string.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.to-string
 2 |   (:require [game.core.card :refer [get-card rezzed? ice? installed? corp? card-index get-title]]
 3 |             [game.core.servers :refer [is-root? zone->name]]))
 4 |
 5 | (defn card-str
 6 |   "Gets a string description of an installed card, reflecting whether it is rezzed,
 7 |   in/protecting a server, facedown, or hosted."
 8 |   ([state card] (card-str state card nil))
 9 |   ([state {:keys [zone host facedown] :as card} {:keys [visible]}]
10 |   (str (if (corp? card)
11 |          (let [installed-ice (and (ice? card) (installed? card))]
12 |            ; Corp card messages
13 |            (str (if (or (rezzed? card)
14 |                         visible)
15 |                   (get-title card)
16 |                   (if installed-ice "ice" "a card"))
17 |                 ; Hosted cards do not need "in server 1" messages, host has them
18 |                 (when-not host
19 |                   (str (cond
20 |                          installed-ice " protecting "
21 |                          (is-root? zone) " in the root of "
22 |                          :else " in ")
23 |                        ;TODO add naming of scoring area of corp/runner
24 |                        (zone->name (or (second zone) zone)) ;; handles [:hand] as well as [:servers :hq]
25 |                        (when installed-ice
26 |                          (str " at position " (card-index state card)))))))
27 |          ; Runner card messages
28 |          (if (or facedown visible)
29 |            "a facedown card"
30 |            (get-title card)))
31 |        (when host (str " hosted on " (card-str state (get-card state host)))))))
32 |

--------------------------------------------------------------------------------
/src/clj/game/core/toasts.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.toasts)
 2 |
 3 | (defn toast
 4 |   "Adds a message to toast with specified severity (default as a warning) to the toast message list.
 5 |   If message is nil, removes first toast in the list.
 6 |   For options see http://codeseven.github.io/toastr/demo.html
 7 |   Currently implemented options:
 8 |     - msg-type (warning, info etc)
 9 |     - time-out (sets both timeOut and extendedTimeOut currently)
10 |     - close-button
11 |     - prevent-duplicates"
12 |   ([state side message] (toast state side message "warning" nil))
13 |   ([state side message msg-type] (toast state side message msg-type nil))
14 |   ([state side message msg-type options]
15 |    ;; Allows passing just the toast msg-type as the options parameter
16 |    (when message
17 |      ;; normal toast - add to list
18 |      (swap! state update-in [side :toast] #(conj % {:msg message :type msg-type :options options :id (random-uuid)})))))
19 |
20 | (defn ack-toast
21 |   ([state side {:keys [id]}]
22 |    (when-let [id (when (string? id) (parse-uuid id))]
23 |      (swap! state update-in [side :toast] (fn [toasts] (remove #(= (:id %) id) toasts))))))
24 |
25 | (defn show-error-toast
26 |   [state side]
27 |   (when state
28 |     (toast state side
29 |            (str "Your last action caused a game error on the server. You can keep playing, but there "
30 |                 "may be errors in the game's current state. Please click the button below to submit a report "
31 |                 "to our GitHub issues page.<br/><br/>Use /error to see this message again.")
32 |            "exception"
33 |            {:time-out 0 :close-button true})))
34 |

--------------------------------------------------------------------------------
/src/clj/game/core/trace.clj:
--------------------------------------------------------------------------------
  1 | (ns game.core.trace
  2 |   (:require
  3 |     [game.core.costs :refer [total-available-credits]]
  4 |     [game.core.effects :refer [any-effects sum-effects get-effects]]
  5 |     [game.core.eid :refer [effect-completed make-eid]]
  6 |     [game.core.engine :refer [can-trigger? pay register-ability-type resolve-ability trigger-event-simult trigger-event-sync]]
  7 |     [game.core.link :refer [get-link]]
  8 |     [game.core.prompts :refer [clear-wait-prompt show-trace-prompt show-wait-prompt]]
  9 |     [game.core.say :refer [system-msg system-say]]
 10 |     [game.macros :refer [continue-ability effect wait-for]]
 11 |     [game.core.payment :refer [->c]]))
 12 |
 13 | (defn- determine-initiator
 14 |   [state {:keys [player]}]
 15 |   (let [runner? (any-effects state nil :trace-runner-spends-first)]
 16 |     (cond
 17 |       runner? :runner
 18 |       (some? player) player
 19 |       :else :corp)))
 20 |
 21 | (defn- corp-start?
 22 |   [trace]
 23 |   (= :corp (:player trace)))
 24 |
 25 | (defn- resolve-trace
 26 |   "Compares trace strength and link strength and triggers the appropriate effects."
 27 |   [state side eid card {:keys [player other base bonus link strength] :as trace} boost]
 28 |   (let [corp-strength (if (corp-start? trace)\
 29 |                         strength\
 30 |                         ((fnil + 0 0 0) base bonus boost))\
 31 |         runner-strength (if (corp-start? trace)\
 32 |                           ((fnil + 0 0) link boost)\
 33 |                           strength)\
 34 |         trigger-trace (select-keys trace [:player :other :base :bonus :link :ability :strength])]
 35 |     (wait-for (pay state other (make-eid state eid) card [(->c :credit boost)])
 36 |               (let [payment-str (:msg async-result)]
 37 |                 (system-msg state other (str payment-str
 38 |                                              " to increase " (if (corp-start? trace) "link" "trace")
 39 |                                              " strength to " (if (corp-start? trace)
 40 |                                                                runner-strength
 41 |                                                                corp-strength))))
 42 |               (clear-wait-prompt state player)
 43 |               (let [successful (> corp-strength runner-strength)\
 44 |                     which-ability (assoc (if successful\
 45 |                                            (:successful trace)\
 46 |                                            (:unsuccessful trace))\
 47 |                                          :eid (make-eid state))]
 48 |                 (system-say state player (str "The trace was " (when-not successful "un") "successful."))
 49 |                 (wait-for (trigger-event-simult state :corp (if successful :successful-trace :unsuccessful-trace)
 50 |                                                 nil ;; No special functions
 51 |                                                 (assoc trigger-trace
 52 |                                                        :corp-strength corp-strength
 53 |                                                        :runner-strength runner-strength
 54 |                                                        :successful successful
 55 |                                                        :corp-spent (if (corp-start? trace)
 56 |                                                                      (- strength base bonus)
 57 |                                                                      boost)
 58 |                                                        :runner-spent (if (corp-start? trace)
 59 |                                                                        boost
 60 |                                                                        (- strength link))))
 61 |                           (wait-for (resolve-ability state :corp (:eid which-ability) which-ability
 62 |                                                      card [corp-strength runner-strength])
 63 |                                     (if-let [kicker (:kicker trace)]
 64 |                                       (if (>= corp-strength (:kicker-min trace))
 65 |                                         (continue-ability state :corp kicker card [corp-strength runner-strength])
 66 |                                         (effect-completed state side eid))
 67 |                                       (effect-completed state side eid))))))))
 68 |
 69 | (defn- beat-trace-amount
 70 |   "finds the number of credits the responder needs to spend to gaurantee success"
 71 |   [initiator corp-credits-fn runner-credits-fn link base strength eid]
 72 |   (let [runner-credits (runner-credits-fn eid)\
 73 |         corp-credits (corp-credits-fn eid)\
 74 |         required (if (= initiator :corp)\
 75 |                    (- strength link)\
 76 |                    (- strength base))]
 77 |     (when (<= required (if (= initiator :corp) runner-credits corp-credits))
 78 |       (max required 0))))
 79 |
 80 | (defn- trace-reply
 81 |   "Shows a trace prompt to the second player, after the first has already spent credits to boost."
 82 |   [state side eid card {:keys [player other base bonus link corp-credits runner-credits] :as trace} boost]
 83 |   (let [trace (dissoc trace :unbeatable)\
 84 |         other-type (if (corp-start? trace) "link" "trace")\
 85 |         strength (if (corp-start? trace)\
 86 |                    ((fnil + 0 0 0) base bonus boost)\
 87 |                    ((fnil + 0 0) link boost))\
 88 |         trace (assoc trace :strength strength :beat-trace (beat-trace-amount player corp-credits runner-credits link base strength eid))]
 89 |     (wait-for (pay state player (make-eid state eid) card [(->c :credit boost)])
 90 |               (let [payment-str (:msg async-result)]
 91 |                 (system-msg state player (str payment-str
 92 |                                               " to increase " (if (corp-start? trace) "trace" "link")
 93 |                                               " strength to " strength)))
 94 |               (clear-wait-prompt state other)
 95 |               (show-wait-prompt state player
 96 |                                 (str (if (corp-start? trace) "Runner" "Corp")
 97 |                                      " to boost " other-type " strength"))
 98 |               (show-trace-prompt state other (make-eid state eid) card
 99 |                                  (str "Boost " other-type " strength?")
100 |                                  #(resolve-trace state side eid card trace %)
101 |                                  trace))))
102 |
103 | (defn- trace-start
104 |   "Starts the trace process by showing the boost prompt to the first player (normally corp)."
105 |   [state side eid card {:keys [player other base bonus label] :as trace}]
106 |   (let [this-type (if (corp-start? trace) "trace" "link")]
107 |     (system-msg state player (str "uses " (:title card)
108 |                                   " to initiate a trace with strength " ((fnil + 0 0) base bonus)
109 |                                   (when (pos? bonus)
110 |                                     (str " (" base " + " bonus ")"))
111 |                                   (when label
112 |                                     (str " (" label ")"))))
113 |     (show-wait-prompt state other
114 |                       (str (if (corp-start? trace) "Corp" "Runner")
115 |                            " to boost " this-type " strength"))
116 |     (show-trace-prompt state player (make-eid state eid) card
117 |                        (str "Boost " this-type " strength?")
118 |                        #(trace-reply state side eid card trace %)
119 |                        trace)))
120 |
121 | (defn- reset-trace-modifications
122 |   [state]
123 |   (swap! state assoc :trace nil))
124 |
125 | (defn force-base
126 |   [state value]
127 |   (swap! state assoc-in [:trace :force-base] value))
128 |
129 | (defn- find-unbeatable-amount
130 |   "finds the number of credits the initiator needs to spend to gaurantee success"
131 |   [initiator corp-credits-fn runner-credits-fn link base eid]
132 |   (let [runner-credits (runner-credits-fn eid)\
133 |         corp-credits (corp-credits-fn eid)\
134 |         required (if (= initiator :corp)\
135 |                    (- (+ runner-credits link 1) base)\
136 |                    (- (+ base corp-credits) link))]
137 |     (when (<= required (if (= initiator :corp) corp-credits runner-credits))
138 |       (max required 0))))
139 |
140 | (defn init-trace
141 |   ([state side card] (init-trace state side (make-eid state {:source-type :trace}) card {:base 0}))
142 |   ([state side card trace] (init-trace state side (make-eid state {:source-type :trace}) card trace))
143 |   ([state side eid card {:keys [base] :as trace}]
144 |    (reset-trace-modifications state)
145 |    (wait-for (trigger-event-sync state :corp :initialize-trace card eid)
146 |              (let [force-base (get-in @state [:trace :force-base])\
147 |                    force-link (first (get-effects state :corp :trace-force-link card [eid]))\
148 |                    base (cond force-base force-base\
149 |                               (fn? base) (base state :corp (make-eid state) card nil)\
150 |                               :else base)\
151 |                    link (or force-link (get-link state))\
152 |                    bonus (sum-effects state :corp :trace-base-strength card [eid])\
153 |                    initiator (determine-initiator state trace)\
154 |                    eid (assoc eid :source-type :trace)\
155 |                    corp-credits #(total-available-credits state :corp % card)\
156 |                    runner-credits #(total-available-credits state :runner % card)\
157 |                    trace (merge trace {:player initiator\
158 |                                        :other (if (= :corp initiator) :runner :corp)\
159 |                                        :unbeatable (find-unbeatable-amount initiator corp-credits runner-credits link base eid)\
160 |                                        :base base\
161 |                                        :bonus bonus\
162 |                                        :link link\
163 |                                        :corp-credits corp-credits\
164 |                                        :runner-credits runner-credits})]
165 |                (reset-trace-modifications state)
166 |                (trace-start state side eid card trace)))))
167 |
168 | (defn- check-trace
169 |   "Checks if there is a trace to resolve"
170 |   [state side {:keys [eid trace] :as ability} card targets]
171 |   (assert (not (contains? trace :async)) "Put :async in the :successful/:unsuccessful")
172 |   (if (can-trigger? state side eid ability card targets)
173 |     (resolve-ability
174 |       state side
175 |       (-> ability
176 |           (dissoc :trace :req)
177 |           (assoc :async true
178 |                  :effect (effect (init-trace eid card trace))))
179 |       card targets)
180 |     (effect-completed state side eid)))
181 |
182 | (register-ability-type :trace #'check-trace)
183 |

--------------------------------------------------------------------------------
/src/clj/game/core/update.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.update
 2 |   (:require [game.core.card :refer [get-card]]
 3 |             [game.core.finding :refer [get-scoring-owner]]
 4 |             [game.utils :refer [to-keyword]]))
 5 |
 6 | (declare update-hosted!)
 7 |
 8 | (defn update!
 9 |   "Updates the state so that its copy of the given card matches the argument given."
10 |   [state side {:keys [type zone cid host] :as card}]
11 |   (cond
12 |     (= type "Identity")
13 |     (when (= side (to-keyword (:side card)))
14 |       (swap! state assoc-in [side :identity] card)
15 |       card)
16 |
17 |     host
18 |     (do (update-hosted! state side card)
19 |         (get-card state card))
20 |
21 |     :else
22 |     (let [z (cons (to-keyword (or (get-scoring-owner state card) (:side card))) zone)\
23 |               [head tail] (split-with #(not= (:cid %) cid) (get-in @state z))]
24 |           (when (not-empty tail)
25 |             (swap! state assoc-in z (vec (concat head [card] (rest tail))))
26 |             card))))
27 |
28 | (defn update-hosted!
29 |   "Updates a card that is hosted on another, by recursively updating the host card's
30 |   :hosted vector."
31 |   [state side {:keys [cid] :as card}]
32 |   (if-let [h (get-card state (:host card))]
33 |     (recur state side (let [[head tail] (split-with #(not= (:cid %) cid) (:hosted h))]
34 |                         (assoc h :hosted (vec (concat head [card] (rest tail))))))
35 |     (when-not (:host card)
36 |       (update! state side card))))
37 |

--------------------------------------------------------------------------------
/src/clj/game/core/virus.clj:
--------------------------------------------------------------------------------
 1 | (ns game.core.virus
 2 |   (:require
 3 |     [game.core.board :refer [all-active-installed get-all-installed all-installed]]
 4 |     [game.core.card :refer [get-counters virus-program?]]))
 5 |
 6 | (defn get-virus-counters
 7 |   "Calculate the number of virus counters on the given card, taking Hivemind into account."
 8 |   [state card]
 9 |   (let [hiveminds (when (virus-program? card)\
10 |                     (filter #(= (:title %) "Hivemind") (all-active-installed state :runner)))]
11 |     (reduce + (map #(get-counters % :virus) (cons card hiveminds)))))
12 |
13 | (defn count-virus-programs
14 |   "Calculate the number of virus programs in play"
15 |   [state]
16 |   (count (filter virus-program? (all-active-installed state :runner))))
17 |
18 | (defn number-of-virus-counters
19 |   "Returns number of actual virus counters (excluding virtual counters from Hivemind)"
20 |   [state]
21 |   (reduce + (map #(get-counters % :virus) (get-all-installed state))))
22 |
23 | (defn number-of-runner-virus-counters
24 |   "Returns the number of actual virus counters on Runner cards (excluding virtual counters from Hivemind)"
25 |   [state]
26 |   (reduce + (map #(get-counters % :virus) (all-installed state :runner))))
27 |

--------------------------------------------------------------------------------
/src/clj/game/core/winning.clj:
--------------------------------------------------------------------------------
  1 | (ns game.core.winning
  2 |   (:require
  3 |    [cljc.java-time.duration :as duration]
  4 |    [cljc.java-time.instant :as inst]
  5 |    [cond-plus.core :refer [cond+]]
  6 |    [game.core.effects :refer [any-effects sum-effects]]
  7 |    [game.core.say :refer [play-sfx system-msg system-say]]
  8 |    [game.utils :refer [dissoc-in]]
  9 |    [jinteki.utils :refer [other-side]]))
 10 |
 11 | (defn win
 12 |   "Records a win reason for statistics."
 13 |   [state side reason]
 14 |   (when-not (:winner @state)
 15 |     (let [started (get-in @state [:stats :time :started])\
 16 |           now (inst/now)\
 17 |           duration (duration/to-minutes (duration/between started now))]
 18 |       (system-msg state side "wins the game")
 19 |       (play-sfx state side "game-end")
 20 |       (swap! state (fn [state]
 21 |                      (-> state
 22 |                          (assoc-in [:stats :time :ended] now)
 23 |                          (assoc-in [:stats :time :elapsed] duration)
 24 |                          (assoc
 25 |                            :winner side
 26 |                            :loser (other-side side)
 27 |                            :winning-user (get-in state [side :user :username])
 28 |                            :losing-user (get-in state [(other-side side) :user :username])
 29 |                            :reason reason
 30 |                            :end-time now
 31 |                            :winning-deck-id (get-in state [side :deck-id])
 32 |                            :losing-deck-id (get-in state [(other-side side) :deck-id])))))
 33 |       true)))
 34 |
 35 | (defn tie
 36 |   "Records a tie reason for statistics."
 37 |   [state reason]
 38 |   (when-not (:winner @state)
 39 |     (let [started (get-in @state [:stats :time :started])\
 40 |           now (inst/now)\
 41 |           duration (duration/to-minutes (duration/between started now))]
 42 |       (system-say state nil "The game is a tie!")
 43 |       (play-sfx state nil "game-end")
 44 |       (swap! state (fn [state]
 45 |                      (-> state
 46 |                          (assoc-in [:stats :time :ended] now)
 47 |                          (assoc-in [:stats :time :elapsed] duration)
 48 |                          (assoc :reason reason
 49 |                                 :end-time now))))
 50 |       true)))
 51 |
 52 | (defn win-decked
 53 |   "Records a win via decking the corp."
 54 |   [state]
 55 |   (system-msg state :corp "is decked")
 56 |   (win state :runner "Decked"))
 57 |
 58 | (defn flatline
 59 |   "Records a win via dealing damage to the runner."
 60 |   [state]
 61 |   (when-not (:winner state)
 62 |     (system-msg state :runner "is flatlined")
 63 |     (win state :corp "Flatline")))
 64 |
 65 | (defn concede
 66 |   "Trigger game concede by specified side. Takes a third argument for use with user commands."
 67 |   ([state side _] (concede state side))
 68 |   ([state side]
 69 |    (system-msg state side "concedes")
 70 |    (win state (if (= side :corp) :runner :corp) "Concede")))
 71 |
 72 | (defn clear-win
 73 |   "Clears the current win condition. Requires both sides to have issued the command"
 74 |   [state side]
 75 |   (swap! state assoc-in [side :clear-win] true)
 76 |   (when (and (-> @state :runner :clear-win) (-> @state :corp :clear-win))
 77 |     (system-msg state side "cleared the win condition")
 78 |     (swap! state dissoc-in [:runner :clear-win])
 79 |     (swap! state dissoc-in [:corp :clear-win])
 80 |     (swap! state dissoc :winner :loser :winning-user :losing-user :reason :winning-deck-id :losing-deck-id :end-time)))
 81 |
 82 | (defn agenda-points-required-to-win
 83 |   [state side]
 84 |   (+ (get-in @state [side :agenda-point-req])
 85 |      (sum-effects state side :agenda-point-req)))
 86 |
 87 | (defn side-win
 88 |   [state side]
 89 |   (<= (agenda-points-required-to-win state side) (get-in @state [side :agenda-point])))
 90 |
 91 | (defn check-win-by-agenda
 92 |   ([state] (check-win-by-agenda state nil))
 93 |   ([state _]
 94 |    (let [corp-win (side-win state :corp)\
 95 |          blocked-corp (any-effects state :corp :cannot-win-on-points)\
 96 |          runner-win (side-win state :runner)\
 97 |          blocked-runner (any-effects state :runner :cannot-win-on-points)]
 98 |      (cond+
 99 |        [(and corp-win (not blocked-corp)\
100 |              runner-win (not blocked-runner))\
101 |         (tie state "Tie")]
102 |        [(and corp-win (not blocked-corp))\
103 |         (win state :corp "Agenda")]
104 |        [(and runner-win (not blocked-runner))\
105 |         (win state :runner "Agenda")]))))
106 |

--------------------------------------------------------------------------------
/src/clj/game/macros.clj:
--------------------------------------------------------------------------------
  1 | (ns game.macros
  2 |   (:require [clojure.tools.analyzer.jvm :as a.j]
  3 |             [clojure.tools.analyzer.ast :as ast]))
  4 |
  5 | (def forms
  6 |   (->>
  7 |     '[\
  8 |       runner (:runner @state)\
  9 |       corp (:corp @state)\
 10 |       run (:run @state)\
 11 |       run-server (get-in @state (concat [:corp :servers] (:server (:run @state))))\
 12 |       run-ices (get-in @state (concat [:corp :servers] (:server (:run @state)) [:ices]))\
 13 |       run-position (get-in @state [:run :position])\
 14 |       current-ice (game.core.ice/get-current-ice state)\
 15 |       corp-reg (get-in @state [:corp :register])\
 16 |       corp-reg-last (get-in @state [:corp :register-last-turn])\
 17 |       runner-reg (get-in @state [:runner :register])\
 18 |       runner-reg-last (get-in @state [:runner :register-last-turn])\
 19 |       target (let [t (first targets)]\
 20 |                (if (and (map? t)\
 21 |                         (contains? t :uuid)\
 22 |                         (contains? t :value))\
 23 |                  (:value t)\
 24 |                  t))\
 25 |       context (let [t (first targets)]\
 26 |                 (if (and (map? t)\
 27 |                          (contains? t :uuid)\
 28 |                          (contains? t :value))\
 29 |                   (:value t)\
 30 |                   t))\
 31 |       installed (#{:rig :servers} (first (game.core.card/get-zone card)))\
 32 |       remotes (game.core.board/get-remote-names state)\
 33 |       servers (game.core.servers/zones->sorted-names (game.core.board/get-zones state))\
 34 |       unprotected (let [server (second (game.core.card/get-zone card))]\
 35 |                     (empty? (get-in @state [:corp :servers server :ices])))\
 36 |       runnable-servers (game.core.servers/zones->sorted-names\
 37 |                          (game.core.runs/get-runnable-zones state side eid card nil))\
 38 |       hq-runnable (some #{:hq} (game.core.runs/get-runnable-zones state))\
 39 |       rd-runnable (some #{:rd} (game.core.runs/get-runnable-zones state))\
 40 |       archives-runnable (some #{:archives} (game.core.runs/get-runnable-zones state))\
 41 |       tagged (jinteki.utils/is-tagged? state)\
 42 |       ;; only intended for use in event listeners on (pre-/post-, un-)successful-run or run-ends\
 43 |       ;; true if the run was initiated by this card\
 44 |       this-card-run (and (get-in card [:special :run-id])\
 45 |                          (= (get-in card [:special :run-id])\
 46 |                             (:run-id (first targets))))\
 47 |       this-server (let [s (game.core.card/get-zone card)\
 48 |                         r (:server (:run @state))]\
 49 |                     (= (second s) (first r)))\
 50 |       corp-currently-drawing (seq (peek (get-in @state [:corp :register :currently-drawing])))\
 51 |       runner-currently-drawing (seq (peek (get-in @state [:runner :register :currently-drawing])))\
 52 |       ]
 53 |     (partition 2)
 54 |     (map (juxt first identity))
 55 |     (into {})))
 56 |
 57 | ;; Taken from https://github.com/Bronsa/tools.analyzer.jvm.deps/commit/8c7c3936e6f73e85f9e7cc122a2142c43d459c12
 58 | ;; TODO: Switch from this inlined function to requiring the right package when the new version drops.
 59 | (defn- find-undefined-locals
 60 |   "Takes a form and returns a set of all the free locals in it"
 61 |   [expr]
 62 |   (->> (binding [a.j/run-passes identity]
 63 |          (a.j/analyze expr (a.j/empty-env)))
 64 |        ast/nodes
 65 |        (filter (fn [{:keys [op]}] (= op :maybe-class)))
 66 |        (map :class)
 67 |        (remove (fn [x] (-> x str (.contains "."))))
 68 |        (into #{})))
 69 |
 70 | (defn- emit-only
 71 |   [needed-locals]
 72 |   (mapcat identity
 73 |           (for [x needed-locals\
 74 |                 :when (contains? forms x)]
 75 |             (get forms x))))
 76 |
 77 | (defn- effect-state-handler
 78 |   [expr]
 79 |   (for [body expr]
 80 |     (if (#{:runner :corp} (second body))
 81 |       (concat [(first body) 'state (second body)] (drop 2 body))
 82 |       (concat [(first body) 'state 'side] (rest body)))))
 83 |
 84 | (defmacro req [& expr]
 85 |   (let [needed-locals (find-undefined-locals expr)\
 86 |         nls (emit-only needed-locals)]
 87 |     `(fn ~['state 'side 'eid 'card 'targets]
 88 |        (assert (or (nil? (:source ~'eid)) (:cid (:source ~'eid)))
 89 |                (str ":source should be a card, received: " (:source ~'eid)))
 90 |        (let [~@nls]
 91 |          ~@expr))))
 92 |
 93 | (defmacro effect [& expr]
 94 |   `(req ~@(effect-state-handler expr)))
 95 |
 96 | (defmacro msg [& expr]
 97 |   `(req (str ~@expr)))
 98 |
 99 | (defmacro wait-for
100 |   [& body]
101 |   (let [[binds action] (if (vector? (first body))\
102 |                          (first body)\
103 |                          [[{'async-result :result}] (first body)])\
104 |         expr (next body)\
105 |         abnormal? (#{'handler 'payable?} (first action))\
106 |         to-take (if abnormal? 4 3)\
107 |         fn-name (gensym (name (first action)))\
108 |         [_ state _ eid?] (if abnormal? (next action) action)]
109 |     `(let [eid?# ~eid?\
110 |            use-eid# (and (map? eid?#) (:eid eid?#))\
111 |            existing-eid# ~(when (contains? &env 'eid) 'eid)\
112 |            new-eid# (if use-eid# eid?# (game.core.eid/make-eid ~state existing-eid#))]
113 |        (game.core.eid/register-effect-completed
114 |          ~state new-eid#
115 |          (fn ~fn-name ~(if (vector? binds) binds [binds])
116 |            ~@expr))
117 |        (if use-eid#
118 |          (~@(take to-take action) new-eid# ~@(drop (inc to-take) action))
119 |          (~@(take to-take action) new-eid# ~@(drop to-take action))))))
120 |
121 | (comment
122 |   (macroexpand
123 |     '(wait-for (draw state :corp (make-eid state) 1)
124 |                (system-msg state :corp async-result)
125 |                (effect-completed state :corp eid)))
126 |   (macroexpand
127 |     '(wait-for [{card :result} (draw state :corp (make-eid state) 1)]
128 |                (system-msg state :corp card)
129 |                (effect-completed state :corp eid)))
130 |   )
131 |
132 | (defmacro continue-ability
133 |   [state side ability card targets]
134 |   `(let [ability# ~ability\
135 |          ability# (if (:eid ability#) ability# (assoc ability# :eid ~'eid))]
136 |      (game.core.engine/resolve-ability ~state ~side ability#  ~card ~targets)))
137 |
138 | (defmacro when-let*
139 |   ([bindings & body]
140 |    (if (seq bindings)
141 |      `(when-let [~(first bindings) ~(second bindings)]
142 |         (when-let* ~(drop 2 bindings) ~@body))
143 |      `(do ~@body))))
144 |

--------------------------------------------------------------------------------
/src/clj/game/main.clj:
--------------------------------------------------------------------------------
 1 | (ns game.main
 2 |   (:require [cheshire.generate :refer [add-encoder encode-str]]
 3 |             [game.core :as core]
 4 |             [game.core.toasts :refer [toast]]))
 5 |
 6 | (add-encoder java.lang.Object encode-str)
 7 |
 8 | (defn set-action-id
 9 |   "Creates a unique action id for each server response - used in client lock"
10 |   [state side]
11 |   (swap! state update-in [side :aid] (fnil inc 0)))
12 |
13 | (defn handle-action
14 |   "Ensures the user is allowed to do command they are trying to do"
15 |   [state side command args]
16 |   (when (core/process-action command state side args)
17 |     (set-action-id state side)))
18 |
19 | (defn handle-concede
20 |   "Concedes victory from the given player."
21 |   [state side]
22 |   (when (and state side)
23 |     (core/concede state side)))
24 |
25 | (defn handle-say
26 |   "Adds a message from a user to the chat log."
27 |   [state side user message]
28 |   (when (and state side)
29 |     (core/command-parser state side {:user (select-keys user [:username :emailhash])
30 |                                      :text message})))
31 |
32 | (defn handle-notification
33 |   ([state text]
34 |    (when state
35 |      (core/system-say state nil text)))
36 |   ([state _ text] (handle-notification state text))
37 |   ([state _ _ text] (handle-notification state text)))
38 |
39 | (defn handle-announcement
40 |   [state text]
41 |   (when state
42 |     (doseq [side [:runner :corp]]
43 |       (toast state side text "warning" {:time-out 0 :close-button true}))))
44 |
45 | (defn handle-rejoin
46 |   [state {:keys [_id username] :as user}]
47 |   (when-let [side (cond\
48 |                     (= _id (get-in @state [:corp :user :_id])) :corp\
49 |                     (= _id (get-in @state [:runner :user :_id])) :runner\
50 |                     :else nil)]
51 |     (swap! state assoc-in [side :user] user)
52 |     (handle-notification state (str username " rejoined the game."))))
53 |

--------------------------------------------------------------------------------
/src/clj/game/quotes.clj:
--------------------------------------------------------------------------------
 1 | (ns game.quotes
 2 |   (:require
 3 |     [clojure.edn :as edn]
 4 |     [clojure.java.io :as io]))
 5 |
 6 |
 7 | (def quotes-corp-filename "data/quotes-corp.edn")
 8 | (def quotes-runner-filename "data/quotes-runner.edn")
 9 | (def generic-key "Default")
10 |
11 | (def identity-quotes (atom {}))
12 |
13 | (defn- load-quote-file [filename]
14 |   (let [file (io/file filename)]
15 |     (when (.exists file)
16 |       (edn/read-string (slurp file)))))
17 |
18 | (defn load-quotes! []
19 |   (reset! identity-quotes (merge (load-quote-file quotes-corp-filename)
20 |                                  (load-quote-file quotes-runner-filename))))
21 |
22 | (defn- choose-and-repeat [options qty]
23 |   (when (not-empty options)
24 |     (repeat qty (first (shuffle options)))))
25 |
26 | (defn make-quote [{player-ident :title} {opp-ident :title opp-faction :faction}]
27 |   (let [generic (get-in @identity-quotes [player-ident generic-key])\
28 |         opp-faction (get-in @identity-quotes [player-ident opp-faction])\
29 |         opp-specific (get-in @identity-quotes [player-ident opp-ident])\
30 |         weighted (concat (choose-and-repeat generic 1)\
31 |                          (choose-and-repeat opp-faction 3)\
32 |                          (choose-and-repeat opp-specific 20))\
33 |         non-blank (filter identity weighted)]
34 |     (if (not-empty non-blank)
35 |       (first (shuffle non-blank))
36 |       "NO QUOTE SRY")))
37 |

--------------------------------------------------------------------------------
/src/clj/game/utils.clj:
--------------------------------------------------------------------------------
  1 | (ns game.utils
  2 |   (:require
  3 |     [jinteki.cards :refer [all-cards]]
  4 |     [clojure.string :as str]
  5 |     [clj-uuid :as uuid]))
  6 |
  7 | (defn make-cid []
  8 |   (uuid/to-string (uuid/v4)))
  9 |
 10 | (defn server-card
 11 |   ([title] (server-card title true))
 12 |   ([title strict?]
 13 |    (let [card (get @all-cards title)]
 14 |      (cond
 15 |        (and title card) card
 16 |        (or (= title "Corp Basic Action Card") (= title "Runner Basic Action Card")) {}
 17 |        :else (when strict?
 18 |                (throw (Exception. (str "Tried to select server-card for " title))))))))
 19 |
 20 | (defn server-cards
 21 |   []
 22 |   (vals @all-cards))
 23 |
 24 | (defn safe-zero?
 25 |   "`zero?` throws up on non numbers, so this is a safe version."
 26 |   [n]
 27 |   ((fnil zero? 1) n))
 28 |
 29 | (defn remove-once [pred coll]
 30 |   (let [[head tail] (split-with (complement pred) coll)]
 31 |     (vec (concat head (rest tail)))))
 32 |
 33 | (defn to-keyword [string]
 34 |   (cond
 35 |     (= "[Credits]" string) :credit
 36 |     (string? string) (keyword (str/lower-case string))
 37 |     :else string))
 38 |
 39 | (defn distinct-by [f coll]
 40 |   (letfn [(step [xs seen]\
 41 |             (lazy-seq (when-let [[x & more] (seq xs)]\
 42 |                         (let [k (f x)]\
 43 |                           (if (seen k)\
 44 |                             (step more seen)\
 45 |                             (cons x (step more (conj seen k))))))))]
 46 |     (step coll #{})))
 47 |
 48 | (defn string->num [s]
 49 |   (try
 50 |     (let [num (bigdec s)]
 51 |       (if (and (> num Integer/MIN_VALUE) (< num Integer/MAX_VALUE)) (int num) num))
 52 |   (catch Exception _ nil)))
 53 |
 54 | (def safe-split (fnil str/split ""))
 55 |
 56 | (defn dissoc-in
 57 |   "Dissociates an entry from a nested associative structure returning a new
 58 |   nested structure. keys is a sequence of keys. Any empty maps that result
 59 |   will not be present in the new structure."
 60 |   [m [k & ks]]
 61 |   (if ks
 62 |     (if-let [nextmap (get m k)]
 63 |       (let [newmap (dissoc-in nextmap ks)]
 64 |         (if (seq newmap)
 65 |           (assoc m k newmap)
 66 |           (dissoc m k)))
 67 |       m)
 68 |     (dissoc m k)))
 69 |
 70 | (defn used-this-turn?
 71 |   "Returns true if a card has been used this turn"
 72 |   [cid state]
 73 |   (contains? (get-in @state [:per-turn]) cid))
 74 |
 75 | (defn side-str
 76 |   "Converts kw into str. If str is passed same str is returned."
 77 |   [side]
 78 |   (cond
 79 |     (= side :corp) "Corp"
 80 |     (= side "Corp") "Corp"
 81 |     (= side :runner) "Runner"
 82 |     (= side "Runner") "Runner"))
 83 |
 84 | (defn same-side?
 85 |   "Checks if two supplied sides are the same side. Accepts both keyword and str."
 86 |   [side1 side2]
 87 |   (= (side-str side1) (side-str side2)))
 88 |
 89 | (defn same-card?
 90 |   "Checks if the two cards are the same by :cid. Alternatively specify 1-function to use to check the card"
 91 |   ([card1 card2] (same-card? :cid card1 card2))
 92 |   ([func card1 card2]
 93 |    (let [id1 (func card1)\
 94 |          id2 (func card2)]
 95 |      (and (some? id1)
 96 |           (some? id2)
 97 |           (= id1 id2)))))
 98 |
 99 | (defn pluralize
100 |   "Makes a string plural based on the number n. Takes specific suffixes for singular and plural cases if necessary."
101 |   ([string n] (pluralize string "s" n))
102 |   ([string suffix n] (pluralize string "" suffix n))
103 |   ([string single-suffix plural-suffix n]
104 |    (if (or (= 1 n)
105 |            (= -1 n))
106 |      (str string single-suffix)
107 |      (str string plural-suffix))))
108 |
109 | (defn quantify
110 |   "Ensures the string is correctly pluralized based on the number n."
111 |   ([n string] (str n " " (pluralize string n)))
112 |   ([n string suffix] (str n " " (pluralize string suffix n)))
113 |   ([n string single-suffix plural-suffix]
114 |    (str n " " (pluralize string single-suffix plural-suffix n))))
115 |
116 | (defn enumerate-str
117 |   "Joins a collection to a string, seperated by commas and 'and' in front of
118 |   the last item. If collection only has one item, justs returns that item
119 |   without seperators. Returns an empty string if coll is empty."
120 |   ([strings] (enumerate-str strings "and"))
121 |   ([strings sep]
122 |    (if (<= (count strings) 2)
123 |      (str/join (str " " sep " ") strings)
124 |     (str (apply str (interpose ", " (butlast strings))) (str ", " sep " ") (last strings)))))
125 |
126 | (defn in-coll?
127 |   "true if coll contains elm"
128 |   [coll elm]
129 |   (some #(= elm %) coll))
130 |
131 | (defn positions
132 |   "Returns the positions of elements in coll matching pred"
133 |   [pred coll]
134 |   (keep-indexed (fn [idx x]
135 |                   (when (pred x)
136 |                     idx))
137 |                 coll))
138 |

--------------------------------------------------------------------------------

```